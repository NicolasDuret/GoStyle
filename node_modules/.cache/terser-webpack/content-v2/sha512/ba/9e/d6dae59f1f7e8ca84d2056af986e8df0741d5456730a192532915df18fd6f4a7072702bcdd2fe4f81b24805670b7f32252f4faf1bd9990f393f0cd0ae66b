{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{nGaW:function(n,t,e){\"use strict\";e.r(t),e.d(t,\"KEYBOARD_DID_CLOSE\",function(){return o}),e.d(t,\"KEYBOARD_DID_OPEN\",function(){return i}),e.d(t,\"copyVisualViewport\",function(){return D}),e.d(t,\"keyboardDidClose\",function(){return b}),e.d(t,\"keyboardDidOpen\",function(){return p}),e.d(t,\"keyboardDidResize\",function(){return w}),e.d(t,\"resetKeyboardAssist\",function(){return a}),e.d(t,\"setKeyboardClose\",function(){return h}),e.d(t,\"setKeyboardOpen\",function(){return c}),e.d(t,\"startKeyboardAssist\",function(){return s}),e.d(t,\"trackViewportChanges\",function(){return v});var i=\"ionKeyboardDidShow\",o=\"ionKeyboardDidHide\",r={},u={},d=!1,a=function(){r={},u={},d=!1},s=function(n){f(n),n.visualViewport&&(u=D(n.visualViewport),n.visualViewport.onresize=function(){v(n),p()||w(n)?c(n):b(n)&&h(n)})},f=function(n){n.addEventListener(\"keyboardDidShow\",function(t){return c(n,t)}),n.addEventListener(\"keyboardDidHide\",function(){return h(n)})},c=function(n,t){g(n,t),d=!0},h=function(n){y(n),d=!1},p=function(){return!d&&r.width===u.width&&(r.height-u.height)*u.scale>150},w=function(n){return d&&!b(n)},b=function(n){return d&&u.height===n.innerHeight},g=function(n,t){var e=new CustomEvent(i,{detail:{keyboardHeight:t?t.keyboardHeight:n.innerHeight-u.height}});n.dispatchEvent(e)},y=function(n){var t=new CustomEvent(o);n.dispatchEvent(t)},v=function(n){r=Object.assign({},u),u=D(n.visualViewport)},D=function(n){return{width:Math.round(n.width),height:Math.round(n.height),offsetTop:n.offsetTop,offsetLeft:n.offsetLeft,pageTop:n.pageTop,pageLeft:n.pageLeft,scale:n.scale}}}}]);","name":"55.d0495e059937baac8fd5.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[55],{\n\n/***/ \"nGaW\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KEYBOARD_DID_CLOSE\", function() { return KEYBOARD_DID_CLOSE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KEYBOARD_DID_OPEN\", function() { return KEYBOARD_DID_OPEN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copyVisualViewport\", function() { return copyVisualViewport; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyboardDidClose\", function() { return keyboardDidClose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyboardDidOpen\", function() { return keyboardDidOpen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyboardDidResize\", function() { return keyboardDidResize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resetKeyboardAssist\", function() { return resetKeyboardAssist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setKeyboardClose\", function() { return setKeyboardClose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setKeyboardOpen\", function() { return setKeyboardOpen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"startKeyboardAssist\", function() { return startKeyboardAssist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"trackViewportChanges\", function() { return trackViewportChanges; });\nvar KEYBOARD_DID_OPEN = 'ionKeyboardDidShow';\nvar KEYBOARD_DID_CLOSE = 'ionKeyboardDidHide';\nvar KEYBOARD_THRESHOLD = 150;\nvar previousVisualViewport = {};\nvar currentVisualViewport = {};\nvar keyboardOpen = false;\n/**\n * This is only used for tests\n */\n\nvar resetKeyboardAssist = function resetKeyboardAssist() {\n  previousVisualViewport = {};\n  currentVisualViewport = {};\n  keyboardOpen = false;\n};\n\nvar startKeyboardAssist = function startKeyboardAssist(win) {\n  startNativeListeners(win);\n\n  if (!win.visualViewport) {\n    return;\n  }\n\n  currentVisualViewport = copyVisualViewport(win.visualViewport);\n\n  win.visualViewport.onresize = function () {\n    trackViewportChanges(win);\n\n    if (keyboardDidOpen() || keyboardDidResize(win)) {\n      setKeyboardOpen(win);\n    } else if (keyboardDidClose(win)) {\n      setKeyboardClose(win);\n    }\n  };\n};\n/**\n * Listen for events fired by native keyboard plugin\n * in Capacitor/Cordova so devs only need to listen\n * in one place.\n */\n\n\nvar startNativeListeners = function startNativeListeners(win) {\n  win.addEventListener('keyboardDidShow', function (ev) {\n    return setKeyboardOpen(win, ev);\n  });\n  win.addEventListener('keyboardDidHide', function () {\n    return setKeyboardClose(win);\n  });\n};\n\nvar setKeyboardOpen = function setKeyboardOpen(win, ev) {\n  fireKeyboardOpenEvent(win, ev);\n  keyboardOpen = true;\n};\n\nvar setKeyboardClose = function setKeyboardClose(win) {\n  fireKeyboardCloseEvent(win);\n  keyboardOpen = false;\n};\n/**\n * Returns `true` if the `keyboardOpen` flag is not\n * set, the previous visual viewport width equal the current\n * visual viewport width, and if the scaled difference\n * of the previous visual viewport height minus the current\n * visual viewport height is greater than KEYBOARD_THRESHOLD\n *\n * We need to be able to accommodate users who have zooming\n * enabled in their browser (or have zoomed in manually) which\n * is why we take into account the current visual viewport's\n * scale value.\n */\n\n\nvar keyboardDidOpen = function keyboardDidOpen() {\n  var scaledHeightDifference = (previousVisualViewport.height - currentVisualViewport.height) * currentVisualViewport.scale;\n  return !keyboardOpen && previousVisualViewport.width === currentVisualViewport.width && scaledHeightDifference > KEYBOARD_THRESHOLD;\n};\n/**\n * Returns `true` if the keyboard is open,\n * but the keyboard did not close\n */\n\n\nvar keyboardDidResize = function keyboardDidResize(win) {\n  return keyboardOpen && !keyboardDidClose(win);\n};\n/**\n * Determine if the keyboard was closed\n * Returns `true` if the `keyboardOpen` flag is set and\n * the current visual viewport height equals the\n * layout viewport height.\n */\n\n\nvar keyboardDidClose = function keyboardDidClose(win) {\n  return keyboardOpen && currentVisualViewport.height === win.innerHeight;\n};\n/**\n * Dispatch a keyboard open event\n */\n\n\nvar fireKeyboardOpenEvent = function fireKeyboardOpenEvent(win, nativeEv) {\n  var keyboardHeight = nativeEv ? nativeEv.keyboardHeight : win.innerHeight - currentVisualViewport.height;\n  var ev = new CustomEvent(KEYBOARD_DID_OPEN, {\n    detail: {\n      keyboardHeight: keyboardHeight\n    }\n  });\n  win.dispatchEvent(ev);\n};\n/**\n * Dispatch a keyboard close event\n */\n\n\nvar fireKeyboardCloseEvent = function fireKeyboardCloseEvent(win) {\n  var ev = new CustomEvent(KEYBOARD_DID_CLOSE);\n  win.dispatchEvent(ev);\n};\n/**\n * Given a window object, create a copy of\n * the current visual and layout viewport states\n * while also preserving the previous visual and\n * layout viewport states\n */\n\n\nvar trackViewportChanges = function trackViewportChanges(win) {\n  previousVisualViewport = Object.assign({}, currentVisualViewport);\n  currentVisualViewport = copyVisualViewport(win.visualViewport);\n};\n/**\n * Creates a deep copy of the visual viewport\n * at a given state\n */\n\n\nvar copyVisualViewport = function copyVisualViewport(visualViewport) {\n  return {\n    width: Math.round(visualViewport.width),\n    height: Math.round(visualViewport.height),\n    offsetTop: visualViewport.offsetTop,\n    offsetLeft: visualViewport.offsetLeft,\n    pageTop: visualViewport.pageTop,\n    pageLeft: visualViewport.pageLeft,\n    scale: visualViewport.scale\n  };\n};\n\n\n\n/***/ })\n\n}]);","inputSourceMap":null}