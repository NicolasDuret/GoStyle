{"ast":null,"code":"import _toConsumableArray from \"/Users/nicolasduret/Desktop/CODE/EPSI/Gostyle last/GoStyle/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/nicolasduret/Desktop/CODE/EPSI/Gostyle last/GoStyle/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _defineProperty from \"/Users/nicolasduret/Desktop/CODE/EPSI/Gostyle last/GoStyle/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _asyncToGenerator from \"/Users/nicolasduret/Desktop/CODE/EPSI/Gostyle last/GoStyle/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/nicolasduret/Desktop/CODE/EPSI/Gostyle last/GoStyle/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/nicolasduret/Desktop/CODE/EPSI/Gostyle last/GoStyle/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _regeneratorRuntime from \"/Users/nicolasduret/Desktop/CODE/EPSI/Gostyle last/GoStyle/node_modules/@babel/runtime/regenerator/index.js\";\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { c as writeTask, r as registerInstance, e as createEvent, f as readTask, h, H as Host, i as getElement, j as forceUpdate } from './index-06cd27b1.js';\nimport { b as getIonMode, c as config, a as isPlatform } from './ionic-global-a049bcbf.js';\nimport { h as hapticSelectionEnd, a as hapticSelectionStart, b as hapticSelectionChanged } from './haptic-9a9aa7ec.js';\nimport { createGesture } from './index-41bf41f2.js';\nimport { s as sanitizeDOMString } from './index-c841c933.js';\nimport { g as getClassMap, c as createColorClasses } from './theme-a24ff1ad.js';\nimport { c as createAnimation } from './animation-c9c2a359.js';\nimport { B as Backdrop } from './backdrop-1b2f5527.js';\nimport { C as CoreDelegate, a as attachComponent, d as detachComponent } from './framework-delegate-a922018c.js';\nimport { d as clamp, g as getElementRoot, r as raf, a as addEventListener, c as componentOnReady, f as focusElement, b as removeEventListener } from './helpers-eed79a2b.js';\nimport { KEYBOARD_DID_OPEN } from './keyboard-808e4e15.js';\nimport { e as deepReady } from './index-c8ef55b5.js';\nimport { g as getTimeGivenProgression } from './cubic-bezier-154a53a5.js';\nimport { R as RippleEffect } from './ripple-effect-0576252b.js';\nimport { S as Spinner } from './spinner-21670fb6.js';\nimport { OVERLAY_BACK_BUTTON_PRIORITY } from './hardware-back-button-ace6a71b.js';\n\nvar createButtonActiveGesture = function createButtonActiveGesture(el, isButton) {\n  var currentTouchedButton;\n  var initialTouchedButton;\n\n  var activateButtonAtPoint = function activateButtonAtPoint(x, y, hapticFeedbackFn) {\n    if (typeof document === 'undefined') {\n      return;\n    }\n\n    var target = document.elementFromPoint(x, y);\n\n    if (!target || !isButton(target)) {\n      clearActiveButton();\n      return;\n    }\n\n    if (target !== currentTouchedButton) {\n      clearActiveButton();\n      setActiveButton(target, hapticFeedbackFn);\n    }\n  };\n\n  var setActiveButton = function setActiveButton(button, hapticFeedbackFn) {\n    currentTouchedButton = button;\n\n    if (!initialTouchedButton) {\n      initialTouchedButton = currentTouchedButton;\n    }\n\n    var buttonToModify = currentTouchedButton;\n    writeTask(function () {\n      return buttonToModify.classList.add('ion-activated');\n    });\n    hapticFeedbackFn();\n  };\n\n  var clearActiveButton = function clearActiveButton() {\n    var dispatchClick = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (!currentTouchedButton) {\n      return;\n    }\n\n    var buttonToModify = currentTouchedButton;\n    writeTask(function () {\n      return buttonToModify.classList.remove('ion-activated');\n    });\n    /**\n     * Clicking on one button, but releasing on another button\n     * does not dispatch a click event in browsers, so we\n     * need to do it manually here. Some browsers will\n     * dispatch a click if clicking on one button, dragging over\n     * another button, and releasing on the original button. In that\n     * case, we need to make sure we do not cause a double click there.\n     */\n\n    if (dispatchClick && initialTouchedButton !== currentTouchedButton) {\n      currentTouchedButton.click();\n    }\n\n    currentTouchedButton = undefined;\n  };\n\n  return createGesture({\n    el: el,\n    gestureName: 'buttonActiveDrag',\n    threshold: 0,\n    onStart: function onStart(ev) {\n      return activateButtonAtPoint(ev.currentX, ev.currentY, hapticSelectionStart);\n    },\n    onMove: function onMove(ev) {\n      return activateButtonAtPoint(ev.currentX, ev.currentY, hapticSelectionChanged);\n    },\n    onEnd: function onEnd() {\n      clearActiveButton(true);\n      hapticSelectionEnd();\n      initialTouchedButton = undefined;\n    }\n  });\n};\n/**\n * iOS Action Sheet Enter Animation\n */\n\n\nvar iosEnterAnimation$6 = function iosEnterAnimation$6(baseEl) {\n  var baseAnimation = createAnimation();\n  var backdropAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 0.01, 'var(--backdrop-opacity)').beforeStyles({\n    'pointer-events': 'none'\n  }).afterClearStyles(['pointer-events']);\n  wrapperAnimation.addElement(baseEl.querySelector('.action-sheet-wrapper')).fromTo('transform', 'translateY(100%)', 'translateY(0%)');\n  return baseAnimation.addElement(baseEl).easing('cubic-bezier(.36,.66,.04,1)').duration(400).addAnimation([backdropAnimation, wrapperAnimation]);\n};\n/**\n * iOS Action Sheet Leave Animation\n */\n\n\nvar iosLeaveAnimation$6 = function iosLeaveAnimation$6(baseEl) {\n  var baseAnimation = createAnimation();\n  var backdropAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0);\n  wrapperAnimation.addElement(baseEl.querySelector('.action-sheet-wrapper')).fromTo('transform', 'translateY(0%)', 'translateY(100%)');\n  return baseAnimation.addElement(baseEl).easing('cubic-bezier(.36,.66,.04,1)').duration(450).addAnimation([backdropAnimation, wrapperAnimation]);\n};\n/**\n * MD Action Sheet Enter Animation\n */\n\n\nvar mdEnterAnimation$5 = function mdEnterAnimation$5(baseEl) {\n  var baseAnimation = createAnimation();\n  var backdropAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 0.01, 'var(--backdrop-opacity)').beforeStyles({\n    'pointer-events': 'none'\n  }).afterClearStyles(['pointer-events']);\n  wrapperAnimation.addElement(baseEl.querySelector('.action-sheet-wrapper')).fromTo('transform', 'translateY(100%)', 'translateY(0%)');\n  return baseAnimation.addElement(baseEl).easing('cubic-bezier(.36,.66,.04,1)').duration(400).addAnimation([backdropAnimation, wrapperAnimation]);\n};\n/**\n * MD Action Sheet Leave Animation\n */\n\n\nvar mdLeaveAnimation$5 = function mdLeaveAnimation$5(baseEl) {\n  var baseAnimation = createAnimation();\n  var backdropAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0);\n  wrapperAnimation.addElement(baseEl.querySelector('.action-sheet-wrapper')).fromTo('transform', 'translateY(0%)', 'translateY(100%)');\n  return baseAnimation.addElement(baseEl).easing('cubic-bezier(.36,.66,.04,1)').duration(450).addAnimation([backdropAnimation, wrapperAnimation]);\n};\n\nvar actionSheetIosCss = \".sc-ion-action-sheet-ios-h{--color:initial;--button-color-activated:var(--button-color);--button-color-focused:var(--button-color);--button-color-hover:var(--button-color);--button-color-selected:var(--button-color);--min-width:auto;--width:100%;--max-width:500px;--min-height:auto;--height:100%;--max-height:calc(100% - (var(--ion-safe-area-top) + var(--ion-safe-area-bottom)));-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;right:0;top:0;bottom:0;display:block;position:fixed;outline:none;font-family:var(--ion-font-family, inherit);-ms-touch-action:none;touch-action:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1001}.overlay-hidden.sc-ion-action-sheet-ios-h{display:none}.action-sheet-wrapper.sc-ion-action-sheet-ios{left:0;right:0;bottom:0;margin-left:auto;margin-right:auto;margin-top:var(--ion-safe-area-top, 0);margin-bottom:var(--ion-safe-area-bottom, 0);-webkit-transform:translate3d(0,  100%,  0);transform:translate3d(0,  100%,  0);display:block;position:absolute;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);z-index:10;pointer-events:none}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.action-sheet-wrapper.sc-ion-action-sheet-ios{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}.action-sheet-button.sc-ion-action-sheet-ios{display:block;position:relative;width:100%;border:0;outline:none;background:var(--button-background);color:var(--button-color);font-family:inherit;overflow:hidden}.action-sheet-button-inner.sc-ion-action-sheet-ios{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;pointer-events:none;width:100%;height:100%;z-index:1}.action-sheet-container.sc-ion-action-sheet-ios{display:-ms-flexbox;display:flex;-ms-flex-flow:column;flex-flow:column;-ms-flex-pack:end;justify-content:flex-end;height:100%;max-height:100%}.action-sheet-group.sc-ion-action-sheet-ios{-ms-flex-negative:2;flex-shrink:2;overscroll-behavior-y:contain;overflow-y:auto;-webkit-overflow-scrolling:touch;pointer-events:all;background:var(--background)}.action-sheet-group.sc-ion-action-sheet-ios::-webkit-scrollbar{display:none}.action-sheet-group-cancel.sc-ion-action-sheet-ios{-ms-flex-negative:0;flex-shrink:0;overflow:hidden}.action-sheet-button.sc-ion-action-sheet-ios::after{left:0;right:0;top:0;bottom:0;position:absolute;content:\\\"\\\";opacity:0}.action-sheet-selected.sc-ion-action-sheet-ios{color:var(--button-color-selected)}.action-sheet-selected.sc-ion-action-sheet-ios::after{background:var(--button-background-selected);opacity:var(--button-background-selected-opacity)}.action-sheet-button.ion-activated.sc-ion-action-sheet-ios{color:var(--button-color-activated)}.action-sheet-button.ion-activated.sc-ion-action-sheet-ios::after{background:var(--button-background-activated);opacity:var(--button-background-activated-opacity)}.action-sheet-button.ion-focused.sc-ion-action-sheet-ios{color:var(--button-color-focused)}.action-sheet-button.ion-focused.sc-ion-action-sheet-ios::after{background:var(--button-background-focused);opacity:var(--button-background-focused-opacity)}@media (any-hover: hover){.action-sheet-button.sc-ion-action-sheet-ios:hover{color:var(--button-color-hover)}.action-sheet-button.sc-ion-action-sheet-ios:hover::after{background:var(--button-background-hover);opacity:var(--button-background-hover-opacity)}}.sc-ion-action-sheet-ios-h{--background:var(--ion-overlay-background-color, var(--ion-color-step-100, #f9f9f9));--backdrop-opacity:var(--ion-backdrop-opacity, 0.4);--button-background:linear-gradient(0deg, rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.08), rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.08) 50%, transparent 50%) bottom/100% 1px no-repeat transparent;--button-background-activated:var(--ion-text-color, #000);--button-background-activated-opacity:.08;--button-background-hover:currentColor;--button-background-hover-opacity:.04;--button-background-focused:currentColor;--button-background-focused-opacity:.12;--button-background-selected:var(--ion-color-step-150, var(--ion-background-color, #fff));--button-background-selected-opacity:1;--button-color:var(--ion-color-primary, #3880ff);--color:var(--ion-color-step-400, #999999);text-align:center}.action-sheet-container.sc-ion-action-sheet-ios{padding-left:8px;padding-right:8px;padding-top:0;padding-bottom:0}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.action-sheet-container.sc-ion-action-sheet-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px}}.action-sheet-group.sc-ion-action-sheet-ios{border-radius:13px;margin-bottom:8px}.action-sheet-group.sc-ion-action-sheet-ios:first-child{margin-top:10px}.action-sheet-group.sc-ion-action-sheet-ios:last-child{margin-bottom:10px}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){.action-sheet-translucent.sc-ion-action-sheet-ios-h .action-sheet-group.sc-ion-action-sheet-ios{background-color:transparent;-webkit-backdrop-filter:saturate(280%) blur(20px);backdrop-filter:saturate(280%) blur(20px)}.action-sheet-translucent.sc-ion-action-sheet-ios-h .action-sheet-title.sc-ion-action-sheet-ios,.action-sheet-translucent.sc-ion-action-sheet-ios-h .action-sheet-button.sc-ion-action-sheet-ios{background-color:transparent;background-image:-webkit-gradient(linear, left bottom, left top, from(rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8)), to(rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8))), -webkit-gradient(linear, left bottom, left top, from(rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.4)), color-stop(50%, rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.4)), color-stop(50%, rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8)));background-image:linear-gradient(0deg, rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8), rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8) 100%), linear-gradient(0deg, rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.4), rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.4) 50%, rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8) 50%);background-repeat:no-repeat;background-position:top, bottom;background-size:100% calc(100% - 1px), 100% 1px;-webkit-backdrop-filter:saturate(120%);backdrop-filter:saturate(120%)}.action-sheet-translucent.sc-ion-action-sheet-ios-h .action-sheet-button.ion-activated.sc-ion-action-sheet-ios{background-color:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.7);background-image:none}.action-sheet-translucent.sc-ion-action-sheet-ios-h .action-sheet-cancel.sc-ion-action-sheet-ios{background:var(--button-background-selected)}}.action-sheet-title.sc-ion-action-sheet-ios{background:-webkit-gradient(linear, left bottom, left top, from(rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.08)), color-stop(50%, rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.08)), color-stop(50%, transparent)) bottom/100% 1px no-repeat transparent;background:linear-gradient(0deg, rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.08), rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.08) 50%, transparent 50%) bottom/100% 1px no-repeat transparent}.action-sheet-title.sc-ion-action-sheet-ios{padding-left:10px;padding-right:10px;padding-top:14px;padding-bottom:13px;color:var(--color, var(--ion-color-step-400, #999999));font-size:13px;font-weight:400;text-align:center}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.action-sheet-title.sc-ion-action-sheet-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:10px;padding-inline-start:10px;-webkit-padding-end:10px;padding-inline-end:10px}}.action-sheet-title.action-sheet-has-sub-title.sc-ion-action-sheet-ios{font-weight:600}.action-sheet-sub-title.sc-ion-action-sheet-ios{padding-left:0;padding-right:0;padding-top:6px;padding-bottom:0;font-size:13px;font-weight:400}.action-sheet-button.sc-ion-action-sheet-ios{padding-left:18px;padding-right:18px;padding-top:18px;padding-bottom:18px;height:56px;font-size:20px;contain:strict}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.action-sheet-button.sc-ion-action-sheet-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:18px;padding-inline-start:18px;-webkit-padding-end:18px;padding-inline-end:18px}}.action-sheet-button.sc-ion-action-sheet-ios .action-sheet-icon.sc-ion-action-sheet-ios{margin-right:0.3em;font-size:28px;pointer-events:none}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.action-sheet-button.sc-ion-action-sheet-ios .action-sheet-icon.sc-ion-action-sheet-ios{margin-right:unset;-webkit-margin-end:0.3em;margin-inline-end:0.3em}}.action-sheet-button.sc-ion-action-sheet-ios:last-child{background-image:none}.action-sheet-selected.sc-ion-action-sheet-ios{font-weight:bold}.action-sheet-cancel.sc-ion-action-sheet-ios{font-weight:600}.action-sheet-cancel.sc-ion-action-sheet-ios::after{background:var(--button-background-selected);opacity:var(--button-background-selected-opacity)}.action-sheet-destructive.sc-ion-action-sheet-ios,.action-sheet-destructive.ion-activated.sc-ion-action-sheet-ios,.action-sheet-destructive.ion-focused.sc-ion-action-sheet-ios{color:var(--ion-color-danger, #eb445a)}@media (any-hover: hover){.action-sheet-destructive.sc-ion-action-sheet-ios:hover{color:var(--ion-color-danger, #eb445a)}}\";\nvar actionSheetMdCss = \".sc-ion-action-sheet-md-h{--color:initial;--button-color-activated:var(--button-color);--button-color-focused:var(--button-color);--button-color-hover:var(--button-color);--button-color-selected:var(--button-color);--min-width:auto;--width:100%;--max-width:500px;--min-height:auto;--height:100%;--max-height:calc(100% - (var(--ion-safe-area-top) + var(--ion-safe-area-bottom)));-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;right:0;top:0;bottom:0;display:block;position:fixed;outline:none;font-family:var(--ion-font-family, inherit);-ms-touch-action:none;touch-action:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1001}.overlay-hidden.sc-ion-action-sheet-md-h{display:none}.action-sheet-wrapper.sc-ion-action-sheet-md{left:0;right:0;bottom:0;margin-left:auto;margin-right:auto;margin-top:var(--ion-safe-area-top, 0);margin-bottom:var(--ion-safe-area-bottom, 0);-webkit-transform:translate3d(0,  100%,  0);transform:translate3d(0,  100%,  0);display:block;position:absolute;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);z-index:10;pointer-events:none}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.action-sheet-wrapper.sc-ion-action-sheet-md{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}.action-sheet-button.sc-ion-action-sheet-md{display:block;position:relative;width:100%;border:0;outline:none;background:var(--button-background);color:var(--button-color);font-family:inherit;overflow:hidden}.action-sheet-button-inner.sc-ion-action-sheet-md{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;pointer-events:none;width:100%;height:100%;z-index:1}.action-sheet-container.sc-ion-action-sheet-md{display:-ms-flexbox;display:flex;-ms-flex-flow:column;flex-flow:column;-ms-flex-pack:end;justify-content:flex-end;height:100%;max-height:100%}.action-sheet-group.sc-ion-action-sheet-md{-ms-flex-negative:2;flex-shrink:2;overscroll-behavior-y:contain;overflow-y:auto;-webkit-overflow-scrolling:touch;pointer-events:all;background:var(--background)}.action-sheet-group.sc-ion-action-sheet-md::-webkit-scrollbar{display:none}.action-sheet-group-cancel.sc-ion-action-sheet-md{-ms-flex-negative:0;flex-shrink:0;overflow:hidden}.action-sheet-button.sc-ion-action-sheet-md::after{left:0;right:0;top:0;bottom:0;position:absolute;content:\\\"\\\";opacity:0}.action-sheet-selected.sc-ion-action-sheet-md{color:var(--button-color-selected)}.action-sheet-selected.sc-ion-action-sheet-md::after{background:var(--button-background-selected);opacity:var(--button-background-selected-opacity)}.action-sheet-button.ion-activated.sc-ion-action-sheet-md{color:var(--button-color-activated)}.action-sheet-button.ion-activated.sc-ion-action-sheet-md::after{background:var(--button-background-activated);opacity:var(--button-background-activated-opacity)}.action-sheet-button.ion-focused.sc-ion-action-sheet-md{color:var(--button-color-focused)}.action-sheet-button.ion-focused.sc-ion-action-sheet-md::after{background:var(--button-background-focused);opacity:var(--button-background-focused-opacity)}@media (any-hover: hover){.action-sheet-button.sc-ion-action-sheet-md:hover{color:var(--button-color-hover)}.action-sheet-button.sc-ion-action-sheet-md:hover::after{background:var(--button-background-hover);opacity:var(--button-background-hover-opacity)}}.sc-ion-action-sheet-md-h{--background:var(--ion-overlay-background-color, var(--ion-background-color, #fff));--backdrop-opacity:var(--ion-backdrop-opacity, 0.32);--button-background:transparent;--button-background-selected:currentColor;--button-background-selected-opacity:0;--button-background-activated:transparent;--button-background-activated-opacity:0;--button-background-hover:currentColor;--button-background-hover-opacity:.04;--button-background-focused:currentColor;--button-background-focused-opacity:.12;--button-color:var(--ion-color-step-850, #262626);--color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.54)}.action-sheet-title.sc-ion-action-sheet-md{padding-left:16px;padding-right:16px;padding-top:20px;padding-bottom:17px;min-height:60px;color:var(--color, rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.54));font-size:16px;text-align:start}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.action-sheet-title.sc-ion-action-sheet-md{padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px}}.action-sheet-sub-title.sc-ion-action-sheet-md{padding-left:0;padding-right:0;padding-top:16px;padding-bottom:0;font-size:14px}.action-sheet-group.sc-ion-action-sheet-md:first-child{padding-top:0}.action-sheet-group.sc-ion-action-sheet-md:last-child{padding-bottom:0}.action-sheet-button.sc-ion-action-sheet-md{padding-left:16px;padding-right:16px;padding-top:0;padding-bottom:0;position:relative;height:52px;font-size:16px;text-align:start;contain:strict;overflow:hidden}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.action-sheet-button.sc-ion-action-sheet-md{padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px}}.action-sheet-icon.sc-ion-action-sheet-md{padding-bottom:4px;margin-left:0;margin-right:32px;margin-top:0;margin-bottom:0;color:var(--color);font-size:24px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.action-sheet-icon.sc-ion-action-sheet-md{margin-left:unset;margin-right:unset;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:32px;margin-inline-end:32px}}.action-sheet-button-inner.sc-ion-action-sheet-md{-ms-flex-pack:start;justify-content:flex-start}.action-sheet-selected.sc-ion-action-sheet-md{font-weight:bold}\";\n\nvar ActionSheet = /*#__PURE__*/function () {\n  function ActionSheet(hostRef) {\n    var _this = this;\n\n    _classCallCheck(this, ActionSheet);\n\n    registerInstance(this, hostRef);\n    this.didPresent = createEvent(this, \"ionActionSheetDidPresent\", 7);\n    this.willPresent = createEvent(this, \"ionActionSheetWillPresent\", 7);\n    this.willDismiss = createEvent(this, \"ionActionSheetWillDismiss\", 7);\n    this.didDismiss = createEvent(this, \"ionActionSheetDidDismiss\", 7);\n    this.presented = false;\n    /**\n     * If `true`, the keyboard will be automatically dismissed when the overlay is presented.\n     */\n\n    this.keyboardClose = true;\n    /**\n     * An array of buttons for the action sheet.\n     */\n\n    this.buttons = [];\n    /**\n     * If `true`, the action sheet will be dismissed when the backdrop is clicked.\n     */\n\n    this.backdropDismiss = true;\n    /**\n     * If `true`, the action sheet will be translucent.\n     * Only applies when the mode is `\"ios\"` and the device supports\n     * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).\n     */\n\n    this.translucent = false;\n    /**\n     * If `true`, the action sheet will animate.\n     */\n\n    this.animated = true;\n\n    this.onBackdropTap = function () {\n      _this.dismiss(undefined, BACKDROP);\n    };\n\n    this.dispatchCancelHandler = function (ev) {\n      var role = ev.detail.role;\n\n      if (isCancel(role)) {\n        var cancelButton = _this.getButtons().find(function (b) {\n          return b.role === 'cancel';\n        });\n\n        _this.callButtonHandler(cancelButton);\n      }\n    };\n  }\n  /**\n   * Present the action sheet overlay after it has been created.\n   */\n\n\n  _createClass(ActionSheet, [{\n    key: \"present\",\n    value: function present() {\n      return _present(this, 'actionSheetEnter', iosEnterAnimation$6, mdEnterAnimation$5);\n    }\n  }, {\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      prepareOverlay(this.el);\n    }\n    /**\n     * Dismiss the action sheet overlay after it has been presented.\n     *\n     * @param data Any data to emit in the dismiss events.\n     * @param role The role of the element that is dismissing the action sheet.\n     * This can be useful in a button handler for determining which button was\n     * clicked to dismiss the action sheet.\n     * Some examples include: ``\"cancel\"`, `\"destructive\"`, \"selected\"`, and `\"backdrop\"`.\n     */\n\n  }, {\n    key: \"dismiss\",\n    value: function dismiss(data, role) {\n      return _dismiss(this, data, role, 'actionSheetLeave', iosLeaveAnimation$6, mdLeaveAnimation$5);\n    }\n    /**\n     * Returns a promise that resolves when the action sheet did dismiss.\n     */\n\n  }, {\n    key: \"onDidDismiss\",\n    value: function onDidDismiss() {\n      return eventMethod(this.el, 'ionActionSheetDidDismiss');\n    }\n    /**\n     * Returns a promise that resolves when the action sheet will dismiss.\n     *\n     */\n\n  }, {\n    key: \"onWillDismiss\",\n    value: function onWillDismiss() {\n      return eventMethod(this.el, 'ionActionSheetWillDismiss');\n    }\n  }, {\n    key: \"buttonClick\",\n    value: function () {\n      var _buttonClick = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(button) {\n        var role, shouldDismiss;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                role = button.role;\n\n                if (!isCancel(role)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this.dismiss(button.data, role));\n\n              case 3:\n                _context.next = 5;\n                return this.callButtonHandler(button);\n\n              case 5:\n                shouldDismiss = _context.sent;\n\n                if (!shouldDismiss) {\n                  _context.next = 8;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this.dismiss(button.data, button.role));\n\n              case 8:\n                return _context.abrupt(\"return\", Promise.resolve());\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function buttonClick(_x) {\n        return _buttonClick.apply(this, arguments);\n      }\n\n      return buttonClick;\n    }()\n  }, {\n    key: \"callButtonHandler\",\n    value: function () {\n      var _callButtonHandler = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(button) {\n        var rtn;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!button) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                _context2.next = 3;\n                return safeCall(button.handler);\n\n              case 3:\n                rtn = _context2.sent;\n\n                if (!(rtn === false)) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", false);\n\n              case 6:\n                return _context2.abrupt(\"return\", true);\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function callButtonHandler(_x2) {\n        return _callButtonHandler.apply(this, arguments);\n      }\n\n      return callButtonHandler;\n    }()\n  }, {\n    key: \"getButtons\",\n    value: function getButtons() {\n      return this.buttons.map(function (b) {\n        return typeof b === 'string' ? {\n          text: b\n        } : b;\n      });\n    }\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      if (this.gesture) {\n        this.gesture.destroy();\n        this.gesture = undefined;\n      }\n    }\n  }, {\n    key: \"componentDidLoad\",\n    value: function componentDidLoad() {\n      var _this2 = this;\n\n      /**\n       * Do not create gesture if:\n       * 1. A gesture already exists\n       * 2. App is running in MD mode\n       * 3. A wrapper ref does not exist\n       */\n      var groupEl = this.groupEl,\n          wrapperEl = this.wrapperEl;\n\n      if (this.gesture || getIonMode(this) === 'md' || !wrapperEl || !groupEl) {\n        return;\n      }\n\n      readTask(function () {\n        var isScrollable = groupEl.scrollHeight > groupEl.clientHeight;\n\n        if (!isScrollable) {\n          _this2.gesture = createButtonActiveGesture(wrapperEl, function (refEl) {\n            return refEl.classList.contains('action-sheet-button');\n          });\n\n          _this2.gesture.enable(true);\n        }\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var htmlAttributes = this.htmlAttributes;\n      var mode = getIonMode(this);\n      var allButtons = this.getButtons();\n      var cancelButton = allButtons.find(function (b) {\n        return b.role === 'cancel';\n      });\n      var buttons = allButtons.filter(function (b) {\n        return b.role !== 'cancel';\n      });\n      return h(Host, Object.assign({\n        role: \"dialog\",\n        \"aria-modal\": \"true\",\n        tabindex: \"-1\"\n      }, htmlAttributes, {\n        style: {\n          zIndex: \"\".concat(20000 + this.overlayIndex)\n        },\n        class: Object.assign(Object.assign(_defineProperty({}, mode, true), getClassMap(this.cssClass)), {\n          'overlay-hidden': true,\n          'action-sheet-translucent': this.translucent\n        }),\n        onIonActionSheetWillDismiss: this.dispatchCancelHandler,\n        onIonBackdropTap: this.onBackdropTap\n      }), h(\"ion-backdrop\", {\n        tappable: this.backdropDismiss\n      }), h(\"div\", {\n        tabindex: \"0\"\n      }), h(\"div\", {\n        class: \"action-sheet-wrapper ion-overlay-wrapper\",\n        role: \"dialog\",\n        ref: function ref(el) {\n          return _this3.wrapperEl = el;\n        }\n      }, h(\"div\", {\n        class: \"action-sheet-container\"\n      }, h(\"div\", {\n        class: \"action-sheet-group\",\n        ref: function ref(el) {\n          return _this3.groupEl = el;\n        }\n      }, this.header !== undefined && h(\"div\", {\n        class: {\n          'action-sheet-title': true,\n          'action-sheet-has-sub-title': this.subHeader !== undefined\n        }\n      }, this.header, this.subHeader && h(\"div\", {\n        class: \"action-sheet-sub-title\"\n      }, this.subHeader)), buttons.map(function (b) {\n        return h(\"button\", {\n          type: \"button\",\n          id: b.id,\n          class: buttonClass$3(b),\n          onClick: function onClick() {\n            return _this3.buttonClick(b);\n          }\n        }, h(\"span\", {\n          class: \"action-sheet-button-inner\"\n        }, b.icon && h(\"ion-icon\", {\n          icon: b.icon,\n          lazy: false,\n          class: \"action-sheet-icon\"\n        }), b.text), mode === 'md' && h(\"ion-ripple-effect\", null));\n      })), cancelButton && h(\"div\", {\n        class: \"action-sheet-group action-sheet-group-cancel\"\n      }, h(\"button\", {\n        type: \"button\",\n        class: buttonClass$3(cancelButton),\n        onClick: function onClick() {\n          return _this3.buttonClick(cancelButton);\n        }\n      }, h(\"span\", {\n        class: \"action-sheet-button-inner\"\n      }, cancelButton.icon && h(\"ion-icon\", {\n        icon: cancelButton.icon,\n        lazy: false,\n        class: \"action-sheet-icon\"\n      }), cancelButton.text), mode === 'md' && h(\"ion-ripple-effect\", null))))), h(\"div\", {\n        tabindex: \"0\"\n      }));\n    }\n  }, {\n    key: \"el\",\n    get: function get() {\n      return getElement(this);\n    }\n  }]);\n\n  return ActionSheet;\n}();\n\nvar buttonClass$3 = function buttonClass$3(button) {\n  return Object.assign(_defineProperty({\n    'action-sheet-button': true,\n    'ion-activatable': true,\n    'ion-focusable': true\n  }, \"action-sheet-\".concat(button.role), button.role !== undefined), getClassMap(button.cssClass));\n};\n\nActionSheet.style = {\n  ios: actionSheetIosCss,\n  md: actionSheetMdCss\n};\n/**\n * iOS Alert Enter Animation\n */\n\nvar iosEnterAnimation$5 = function iosEnterAnimation$5(baseEl) {\n  var baseAnimation = createAnimation();\n  var backdropAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 0.01, 'var(--backdrop-opacity)').beforeStyles({\n    'pointer-events': 'none'\n  }).afterClearStyles(['pointer-events']);\n  wrapperAnimation.addElement(baseEl.querySelector('.alert-wrapper')).keyframes([{\n    offset: 0,\n    opacity: '0.01',\n    transform: 'scale(1.1)'\n  }, {\n    offset: 1,\n    opacity: '1',\n    transform: 'scale(1)'\n  }]);\n  return baseAnimation.addElement(baseEl).easing('ease-in-out').duration(200).addAnimation([backdropAnimation, wrapperAnimation]);\n};\n/**\n * iOS Alert Leave Animation\n */\n\n\nvar iosLeaveAnimation$5 = function iosLeaveAnimation$5(baseEl) {\n  var baseAnimation = createAnimation();\n  var backdropAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0);\n  wrapperAnimation.addElement(baseEl.querySelector('.alert-wrapper')).keyframes([{\n    offset: 0,\n    opacity: 0.99,\n    transform: 'scale(1)'\n  }, {\n    offset: 1,\n    opacity: 0,\n    transform: 'scale(0.9)'\n  }]);\n  return baseAnimation.addElement(baseEl).easing('ease-in-out').duration(200).addAnimation([backdropAnimation, wrapperAnimation]);\n};\n/**\n * Md Alert Enter Animation\n */\n\n\nvar mdEnterAnimation$4 = function mdEnterAnimation$4(baseEl) {\n  var baseAnimation = createAnimation();\n  var backdropAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 0.01, 'var(--backdrop-opacity)').beforeStyles({\n    'pointer-events': 'none'\n  }).afterClearStyles(['pointer-events']);\n  wrapperAnimation.addElement(baseEl.querySelector('.alert-wrapper')).keyframes([{\n    offset: 0,\n    opacity: '0.01',\n    transform: 'scale(0.9)'\n  }, {\n    offset: 1,\n    opacity: '1',\n    transform: 'scale(1)'\n  }]);\n  return baseAnimation.addElement(baseEl).easing('ease-in-out').duration(150).addAnimation([backdropAnimation, wrapperAnimation]);\n};\n/**\n * Md Alert Leave Animation\n */\n\n\nvar mdLeaveAnimation$4 = function mdLeaveAnimation$4(baseEl) {\n  var baseAnimation = createAnimation();\n  var backdropAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0);\n  wrapperAnimation.addElement(baseEl.querySelector('.alert-wrapper')).fromTo('opacity', 0.99, 0);\n  return baseAnimation.addElement(baseEl).easing('ease-in-out').duration(150).addAnimation([backdropAnimation, wrapperAnimation]);\n};\n\nvar alertIosCss = \".sc-ion-alert-ios-h{--min-width:250px;--width:auto;--min-height:auto;--height:auto;--max-height:90%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;font-family:var(--ion-font-family, inherit);contain:strict;-ms-touch-action:none;touch-action:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1001}.overlay-hidden.sc-ion-alert-ios-h{display:none}.alert-top.sc-ion-alert-ios-h{padding-top:50px;-ms-flex-align:start;align-items:flex-start}.alert-wrapper.sc-ion-alert-ios{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);contain:content;opacity:0;z-index:10}.alert-title.sc-ion-alert-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0}.alert-sub-title.sc-ion-alert-ios{margin-left:0;margin-right:0;margin-top:5px;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;font-weight:normal}.alert-message.sc-ion-alert-ios{-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-overflow-scrolling:touch;overflow-y:auto;overscroll-behavior-y:contain}.alert-checkbox-group.sc-ion-alert-ios::-webkit-scrollbar,.alert-radio-group.sc-ion-alert-ios::-webkit-scrollbar,.alert-message.sc-ion-alert-ios::-webkit-scrollbar{display:none}.alert-input.sc-ion-alert-ios{padding-left:0;padding-right:0;padding-top:10px;padding-bottom:10px;width:100%;border:0;background:inherit;font:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}.alert-button-group.sc-ion-alert-ios{display:-ms-flexbox;display:flex;-ms-flex-direction:row;flex-direction:row;width:100%}.alert-button-group-vertical.sc-ion-alert-ios{-ms-flex-direction:column;flex-direction:column;-ms-flex-wrap:nowrap;flex-wrap:nowrap}.alert-button.sc-ion-alert-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:block;border:0;font-size:14px;line-height:20px;z-index:0}.alert-button.ion-focused.sc-ion-alert-ios,.alert-tappable.ion-focused.sc-ion-alert-ios{background:var(--ion-color-step-100, #e6e6e6)}.alert-button-inner.sc-ion-alert-ios{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%}.alert-input-disabled.sc-ion-alert-ios,.alert-checkbox-button-disabled.sc-ion-alert-ios .alert-button-inner.sc-ion-alert-ios,.alert-radio-button-disabled.sc-ion-alert-ios .alert-button-inner.sc-ion-alert-ios{cursor:default;opacity:0.5;pointer-events:none}.alert-tappable.sc-ion-alert-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:-ms-flexbox;display:flex;width:100%;border:0;background:transparent;font-size:inherit;line-height:initial;text-align:start;-webkit-appearance:none;-moz-appearance:none;appearance:none;contain:strict}.alert-button.sc-ion-alert-ios,.alert-checkbox.sc-ion-alert-ios,.alert-input.sc-ion-alert-ios,.alert-radio.sc-ion-alert-ios{outline:none}.alert-radio-icon.sc-ion-alert-ios,.alert-checkbox-icon.sc-ion-alert-ios,.alert-checkbox-inner.sc-ion-alert-ios{-webkit-box-sizing:border-box;box-sizing:border-box}textarea.alert-input.sc-ion-alert-ios{min-height:37px;resize:none}.sc-ion-alert-ios-h{--background:var(--ion-overlay-background-color, var(--ion-color-step-100, #f9f9f9));--max-width:270px;--backdrop-opacity:var(--ion-backdrop-opacity, 0.3);font-size:14px}.alert-wrapper.sc-ion-alert-ios{border-radius:13px;-webkit-box-shadow:none;box-shadow:none;overflow:hidden}.alert-button.sc-ion-alert-ios .alert-button-inner.sc-ion-alert-ios{pointer-events:none}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){.alert-translucent.sc-ion-alert-ios-h .alert-wrapper.sc-ion-alert-ios{background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.9);-webkit-backdrop-filter:saturate(180%) blur(20px);backdrop-filter:saturate(180%) blur(20px)}}.alert-head.sc-ion-alert-ios{padding-left:16px;padding-right:16px;padding-top:12px;padding-bottom:7px;text-align:center}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.alert-head.sc-ion-alert-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px}}.alert-title.sc-ion-alert-ios{margin-top:8px;color:var(--ion-text-color, #000);font-size:17px;font-weight:600}.alert-sub-title.sc-ion-alert-ios{color:var(--ion-color-step-600, #666666);font-size:14px}.alert-message.sc-ion-alert-ios,.alert-input-group.sc-ion-alert-ios{padding-left:16px;padding-right:16px;padding-top:0;padding-bottom:21px;color:var(--ion-text-color, #000);font-size:13px;text-align:center}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.alert-message.sc-ion-alert-ios,.alert-input-group.sc-ion-alert-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px}}.alert-message.sc-ion-alert-ios{max-height:240px}.alert-message.sc-ion-alert-ios:empty{padding-left:0;padding-right:0;padding-top:0;padding-bottom:12px}.alert-input.sc-ion-alert-ios{border-radius:4px;margin-top:10px;padding-left:6px;padding-right:6px;padding-top:6px;padding-bottom:6px;border:0.55px solid var(--ion-color-step-250, #bfbfbf);background-color:var(--ion-background-color, #fff);-webkit-appearance:none;-moz-appearance:none;appearance:none}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.alert-input.sc-ion-alert-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:6px;padding-inline-start:6px;-webkit-padding-end:6px;padding-inline-end:6px}}.alert-input.sc-ion-alert-ios::-webkit-input-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-ios::-moz-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-ios:-ms-input-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-ios::-ms-input-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-ios::placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-ios::-ms-clear{display:none}.alert-radio-group.sc-ion-alert-ios,.alert-checkbox-group.sc-ion-alert-ios{-ms-scroll-chaining:none;overscroll-behavior:contain;max-height:240px;border-top:0.55px solid rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2);overflow-y:auto;-webkit-overflow-scrolling:touch}.alert-tappable.sc-ion-alert-ios{height:44px}.alert-radio-label.sc-ion-alert-ios{padding-left:13px;padding-right:13px;padding-top:13px;padding-bottom:13px;-ms-flex:1;flex:1;-ms-flex-order:0;order:0;color:var(--ion-text-color, #000);text-overflow:ellipsis;white-space:nowrap;overflow:hidden}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.alert-radio-label.sc-ion-alert-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:13px;padding-inline-start:13px;-webkit-padding-end:13px;padding-inline-end:13px}}[aria-checked=true].sc-ion-alert-ios .alert-radio-label.sc-ion-alert-ios{color:var(--ion-color-primary, #3880ff)}.alert-radio-icon.sc-ion-alert-ios{position:relative;-ms-flex-order:1;order:1;min-width:30px}[aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios{left:7px;top:-7px;position:absolute;width:6px;height:12px;-webkit-transform:rotate(45deg);transform:rotate(45deg);border-width:2px;border-top-width:0;border-left-width:0;border-style:solid;border-color:var(--ion-color-primary, #3880ff)}[dir=rtl].sc-ion-alert-ios [aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios,[dir=rtl].sc-ion-alert-ios-h [aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios,[dir=rtl] .sc-ion-alert-ios-h [aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios{left:unset;right:unset;right:7px}.alert-checkbox-label.sc-ion-alert-ios{padding-left:13px;padding-right:13px;padding-top:13px;padding-bottom:13px;-ms-flex:1;flex:1;color:var(--ion-text-color, #000);text-overflow:ellipsis;white-space:nowrap;overflow:hidden}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.alert-checkbox-label.sc-ion-alert-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:13px;padding-inline-start:13px;-webkit-padding-end:13px;padding-inline-end:13px}}.alert-checkbox-icon.sc-ion-alert-ios{border-radius:50%;margin-left:16px;margin-right:6px;margin-top:10px;margin-bottom:10px;position:relative;width:24px;height:24px;border-width:1px;border-style:solid;border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, #c8c7cc)));background-color:var(--ion-item-background, var(--ion-background-color, #fff));contain:strict}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.alert-checkbox-icon.sc-ion-alert-ios{margin-left:unset;margin-right:unset;-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:6px;margin-inline-end:6px}}[aria-checked=true].sc-ion-alert-ios .alert-checkbox-icon.sc-ion-alert-ios{border-color:var(--ion-color-primary, #3880ff);background-color:var(--ion-color-primary, #3880ff)}[aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios{left:9px;top:4px;position:absolute;width:5px;height:12px;-webkit-transform:rotate(45deg);transform:rotate(45deg);border-width:1px;border-top-width:0;border-left-width:0;border-style:solid;border-color:var(--ion-background-color, #fff)}[dir=rtl].sc-ion-alert-ios [aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios,[dir=rtl].sc-ion-alert-ios-h [aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios,[dir=rtl] .sc-ion-alert-ios-h [aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios{left:unset;right:unset;right:9px}.alert-button-group.sc-ion-alert-ios{margin-right:-0.55px;-ms-flex-wrap:wrap;flex-wrap:wrap}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.alert-button-group.sc-ion-alert-ios{margin-right:unset;-webkit-margin-end:-0.55px;margin-inline-end:-0.55px}}.alert-button.sc-ion-alert-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;border-radius:0;-ms-flex:1 1 auto;flex:1 1 auto;min-width:50%;height:44px;border-top:0.55px solid rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2);border-right:0.55px solid rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2);background-color:transparent;color:var(--ion-color-primary, #3880ff);font-size:17px;overflow:hidden}[dir=rtl].sc-ion-alert-ios .alert-button.sc-ion-alert-ios:first-child,[dir=rtl].sc-ion-alert-ios-h .alert-button.sc-ion-alert-ios:first-child,[dir=rtl] .sc-ion-alert-ios-h .alert-button.sc-ion-alert-ios:first-child{border-right:0}.alert-button.sc-ion-alert-ios:last-child{border-right:0;font-weight:bold}[dir=rtl].sc-ion-alert-ios .alert-button.sc-ion-alert-ios:last-child,[dir=rtl].sc-ion-alert-ios-h .alert-button.sc-ion-alert-ios:last-child,[dir=rtl] .sc-ion-alert-ios-h .alert-button.sc-ion-alert-ios:last-child{border-right:0.55px solid rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2)}.alert-button.ion-activated.sc-ion-alert-ios{background-color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.1)}.alert-button-role-destructive.sc-ion-alert-ios,.alert-button-role-destructive.ion-activated.sc-ion-alert-ios,.alert-button-role-destructive.ion-focused.sc-ion-alert-ios{color:var(--ion-color-danger, #eb445a)}\";\nvar alertMdCss = \".sc-ion-alert-md-h{--min-width:250px;--width:auto;--min-height:auto;--height:auto;--max-height:90%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;font-family:var(--ion-font-family, inherit);contain:strict;-ms-touch-action:none;touch-action:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1001}.overlay-hidden.sc-ion-alert-md-h{display:none}.alert-top.sc-ion-alert-md-h{padding-top:50px;-ms-flex-align:start;align-items:flex-start}.alert-wrapper.sc-ion-alert-md{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);contain:content;opacity:0;z-index:10}.alert-title.sc-ion-alert-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0}.alert-sub-title.sc-ion-alert-md{margin-left:0;margin-right:0;margin-top:5px;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;font-weight:normal}.alert-message.sc-ion-alert-md{-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-overflow-scrolling:touch;overflow-y:auto;overscroll-behavior-y:contain}.alert-checkbox-group.sc-ion-alert-md::-webkit-scrollbar,.alert-radio-group.sc-ion-alert-md::-webkit-scrollbar,.alert-message.sc-ion-alert-md::-webkit-scrollbar{display:none}.alert-input.sc-ion-alert-md{padding-left:0;padding-right:0;padding-top:10px;padding-bottom:10px;width:100%;border:0;background:inherit;font:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}.alert-button-group.sc-ion-alert-md{display:-ms-flexbox;display:flex;-ms-flex-direction:row;flex-direction:row;width:100%}.alert-button-group-vertical.sc-ion-alert-md{-ms-flex-direction:column;flex-direction:column;-ms-flex-wrap:nowrap;flex-wrap:nowrap}.alert-button.sc-ion-alert-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:block;border:0;font-size:14px;line-height:20px;z-index:0}.alert-button.ion-focused.sc-ion-alert-md,.alert-tappable.ion-focused.sc-ion-alert-md{background:var(--ion-color-step-100, #e6e6e6)}.alert-button-inner.sc-ion-alert-md{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%}.alert-input-disabled.sc-ion-alert-md,.alert-checkbox-button-disabled.sc-ion-alert-md .alert-button-inner.sc-ion-alert-md,.alert-radio-button-disabled.sc-ion-alert-md .alert-button-inner.sc-ion-alert-md{cursor:default;opacity:0.5;pointer-events:none}.alert-tappable.sc-ion-alert-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:-ms-flexbox;display:flex;width:100%;border:0;background:transparent;font-size:inherit;line-height:initial;text-align:start;-webkit-appearance:none;-moz-appearance:none;appearance:none;contain:strict}.alert-button.sc-ion-alert-md,.alert-checkbox.sc-ion-alert-md,.alert-input.sc-ion-alert-md,.alert-radio.sc-ion-alert-md{outline:none}.alert-radio-icon.sc-ion-alert-md,.alert-checkbox-icon.sc-ion-alert-md,.alert-checkbox-inner.sc-ion-alert-md{-webkit-box-sizing:border-box;box-sizing:border-box}textarea.alert-input.sc-ion-alert-md{min-height:37px;resize:none}.sc-ion-alert-md-h{--background:var(--ion-overlay-background-color, var(--ion-background-color, #fff));--max-width:280px;--backdrop-opacity:var(--ion-backdrop-opacity, 0.32);font-size:14px}.alert-wrapper.sc-ion-alert-md{border-radius:4px;-webkit-box-shadow:0 11px 15px -7px rgba(0, 0, 0, 0.2), 0 24px 38px 3px rgba(0, 0, 0, 0.14), 0 9px 46px 8px rgba(0, 0, 0, 0.12);box-shadow:0 11px 15px -7px rgba(0, 0, 0, 0.2), 0 24px 38px 3px rgba(0, 0, 0, 0.14), 0 9px 46px 8px rgba(0, 0, 0, 0.12)}.alert-head.sc-ion-alert-md{padding-left:23px;padding-right:23px;padding-top:20px;padding-bottom:15px;text-align:start}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.alert-head.sc-ion-alert-md{padding-left:unset;padding-right:unset;-webkit-padding-start:23px;padding-inline-start:23px;-webkit-padding-end:23px;padding-inline-end:23px}}.alert-title.sc-ion-alert-md{color:var(--ion-text-color, #000);font-size:20px;font-weight:500}.alert-sub-title.sc-ion-alert-md{color:var(--ion-text-color, #000);font-size:16px}.alert-message.sc-ion-alert-md,.alert-input-group.sc-ion-alert-md{padding-left:24px;padding-right:24px;padding-top:20px;padding-bottom:20px;color:var(--ion-color-step-550, #737373)}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.alert-message.sc-ion-alert-md,.alert-input-group.sc-ion-alert-md{padding-left:unset;padding-right:unset;-webkit-padding-start:24px;padding-inline-start:24px;-webkit-padding-end:24px;padding-inline-end:24px}}.alert-message.sc-ion-alert-md{max-height:266px;font-size:16px}.alert-message.sc-ion-alert-md:empty{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0}.alert-head.sc-ion-alert-md+.alert-message.sc-ion-alert-md{padding-top:0}.alert-input.sc-ion-alert-md{margin-left:0;margin-right:0;margin-top:5px;margin-bottom:5px;border-bottom:1px solid var(--ion-color-step-150, #d9d9d9);color:var(--ion-text-color, #000)}.alert-input.sc-ion-alert-md::-webkit-input-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-md::-moz-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-md:-ms-input-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-md::-ms-input-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-md::placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-md::-ms-clear{display:none}.alert-input.sc-ion-alert-md:focus{margin-bottom:4px;border-bottom:2px solid var(--ion-color-primary, #3880ff)}.alert-radio-group.sc-ion-alert-md,.alert-checkbox-group.sc-ion-alert-md{position:relative;max-height:266px;border-top:1px solid var(--ion-color-step-150, #d9d9d9);border-bottom:1px solid var(--ion-color-step-150, #d9d9d9);overflow:auto}.alert-tappable.sc-ion-alert-md{position:relative;height:48px;overflow:hidden}.alert-radio-label.sc-ion-alert-md{padding-left:52px;padding-right:26px;padding-top:13px;padding-bottom:13px;-ms-flex:1;flex:1;color:var(--ion-color-step-850, #262626);font-size:16px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.alert-radio-label.sc-ion-alert-md{padding-left:unset;padding-right:unset;-webkit-padding-start:52px;padding-inline-start:52px;-webkit-padding-end:26px;padding-inline-end:26px}}.alert-radio-icon.sc-ion-alert-md{left:26px;top:0;border-radius:50%;display:block;position:relative;width:20px;height:20px;border-width:2px;border-style:solid;border-color:var(--ion-color-step-550, #737373)}[dir=rtl].sc-ion-alert-md .alert-radio-icon.sc-ion-alert-md,[dir=rtl].sc-ion-alert-md-h .alert-radio-icon.sc-ion-alert-md,[dir=rtl] .sc-ion-alert-md-h .alert-radio-icon.sc-ion-alert-md{left:unset;right:unset;right:26px}.alert-radio-inner.sc-ion-alert-md{left:3px;top:3px;border-radius:50%;position:absolute;width:10px;height:10px;-webkit-transform:scale3d(0, 0, 0);transform:scale3d(0, 0, 0);-webkit-transition:-webkit-transform 280ms cubic-bezier(0.4, 0, 0.2, 1);transition:-webkit-transform 280ms cubic-bezier(0.4, 0, 0.2, 1);transition:transform 280ms cubic-bezier(0.4, 0, 0.2, 1);transition:transform 280ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 280ms cubic-bezier(0.4, 0, 0.2, 1);background-color:var(--ion-color-primary, #3880ff)}[dir=rtl].sc-ion-alert-md .alert-radio-inner.sc-ion-alert-md,[dir=rtl].sc-ion-alert-md-h .alert-radio-inner.sc-ion-alert-md,[dir=rtl] .sc-ion-alert-md-h .alert-radio-inner.sc-ion-alert-md{left:unset;right:unset;right:3px}[aria-checked=true].sc-ion-alert-md .alert-radio-label.sc-ion-alert-md{color:var(--ion-color-step-850, #262626)}[aria-checked=true].sc-ion-alert-md .alert-radio-icon.sc-ion-alert-md{border-color:var(--ion-color-primary, #3880ff)}[aria-checked=true].sc-ion-alert-md .alert-radio-inner.sc-ion-alert-md{-webkit-transform:scale3d(1, 1, 1);transform:scale3d(1, 1, 1)}.alert-checkbox-label.sc-ion-alert-md{padding-left:53px;padding-right:26px;padding-top:13px;padding-bottom:13px;-ms-flex:1;flex:1;color:var(--ion-color-step-850, #262626);font-size:16px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.alert-checkbox-label.sc-ion-alert-md{padding-left:unset;padding-right:unset;-webkit-padding-start:53px;padding-inline-start:53px;-webkit-padding-end:26px;padding-inline-end:26px}}.alert-checkbox-icon.sc-ion-alert-md{left:26px;top:0;border-radius:2px;position:relative;width:16px;height:16px;border-width:2px;border-style:solid;border-color:var(--ion-color-step-550, #737373);contain:strict}[dir=rtl].sc-ion-alert-md .alert-checkbox-icon.sc-ion-alert-md,[dir=rtl].sc-ion-alert-md-h .alert-checkbox-icon.sc-ion-alert-md,[dir=rtl] .sc-ion-alert-md-h .alert-checkbox-icon.sc-ion-alert-md{left:unset;right:unset;right:26px}[aria-checked=true].sc-ion-alert-md .alert-checkbox-icon.sc-ion-alert-md{border-color:var(--ion-color-primary, #3880ff);background-color:var(--ion-color-primary, #3880ff)}[aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md{left:3px;top:0;position:absolute;width:6px;height:10px;-webkit-transform:rotate(45deg);transform:rotate(45deg);border-width:2px;border-top-width:0;border-left-width:0;border-style:solid;border-color:var(--ion-color-primary-contrast, #fff)}[dir=rtl].sc-ion-alert-md [aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md,[dir=rtl].sc-ion-alert-md-h [aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md,[dir=rtl] .sc-ion-alert-md-h [aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md{left:unset;right:unset;right:3px}.alert-button-group.sc-ion-alert-md{padding-left:8px;padding-right:8px;padding-top:8px;padding-bottom:8px;-webkit-box-sizing:border-box;box-sizing:border-box;-ms-flex-wrap:wrap-reverse;flex-wrap:wrap-reverse;-ms-flex-pack:end;justify-content:flex-end}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.alert-button-group.sc-ion-alert-md{padding-left:unset;padding-right:unset;-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px}}.alert-button.sc-ion-alert-md{border-radius:2px;margin-left:0;margin-right:8px;margin-top:0;margin-bottom:0;padding-left:10px;padding-right:10px;padding-top:10px;padding-bottom:10px;position:relative;background-color:transparent;color:var(--ion-color-primary, #3880ff);font-weight:500;text-align:end;text-transform:uppercase;overflow:hidden}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.alert-button.sc-ion-alert-md{margin-left:unset;margin-right:unset;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:8px;margin-inline-end:8px}}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.alert-button.sc-ion-alert-md{padding-left:unset;padding-right:unset;-webkit-padding-start:10px;padding-inline-start:10px;-webkit-padding-end:10px;padding-inline-end:10px}}.alert-button-inner.sc-ion-alert-md{-ms-flex-pack:end;justify-content:flex-end}\";\n\nvar Alert = /*#__PURE__*/function () {\n  function Alert(hostRef) {\n    var _this4 = this;\n\n    _classCallCheck(this, Alert);\n\n    registerInstance(this, hostRef);\n    this.didPresent = createEvent(this, \"ionAlertDidPresent\", 7);\n    this.willPresent = createEvent(this, \"ionAlertWillPresent\", 7);\n    this.willDismiss = createEvent(this, \"ionAlertWillDismiss\", 7);\n    this.didDismiss = createEvent(this, \"ionAlertDidDismiss\", 7);\n    this.processedInputs = [];\n    this.processedButtons = [];\n    this.presented = false;\n    /**\n     * If `true`, the keyboard will be automatically dismissed when the overlay is presented.\n     */\n\n    this.keyboardClose = true;\n    /**\n     * Array of buttons to be added to the alert.\n     */\n\n    this.buttons = [];\n    /**\n     * Array of input to show in the alert.\n     */\n\n    this.inputs = [];\n    /**\n     * If `true`, the alert will be dismissed when the backdrop is clicked.\n     */\n\n    this.backdropDismiss = true;\n    /**\n     * If `true`, the alert will be translucent.\n     * Only applies when the mode is `\"ios\"` and the device supports\n     * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).\n     */\n\n    this.translucent = false;\n    /**\n     * If `true`, the alert will animate.\n     */\n\n    this.animated = true;\n\n    this.onBackdropTap = function () {\n      _this4.dismiss(undefined, BACKDROP);\n    };\n\n    this.dispatchCancelHandler = function (ev) {\n      var role = ev.detail.role;\n\n      if (isCancel(role)) {\n        var cancelButton = _this4.processedButtons.find(function (b) {\n          return b.role === 'cancel';\n        });\n\n        _this4.callButtonHandler(cancelButton);\n      }\n    };\n  }\n\n  _createClass(Alert, [{\n    key: \"onKeydown\",\n    value: function onKeydown(ev) {\n      var inputTypes = new Set(this.processedInputs.map(function (i) {\n        return i.type;\n      })); // The only inputs we want to navigate between using arrow keys are the radios\n      // ignore the keydown event if it is not on a radio button\n\n      if (!inputTypes.has('radio') || ev.target && !this.el.contains(ev.target) || ev.target.classList.contains('alert-button')) {\n        return;\n      } // Get all radios inside of the radio group and then\n      // filter out disabled radios since we need to skip those\n\n\n      var query = this.el.querySelectorAll('.alert-radio');\n      var radios = Array.from(query).filter(function (radio) {\n        return !radio.disabled;\n      }); // The focused radio is the one that shares the same id as\n      // the event target\n\n      var index = radios.findIndex(function (radio) {\n        return radio.id === ev.target.id;\n      }); // We need to know what the next radio element should\n      // be in order to change the focus\n\n      var nextEl; // If hitting arrow down or arrow right, move to the next radio\n      // If we're on the last radio, move to the first radio\n\n      if (['ArrowDown', 'ArrowRight'].includes(ev.code)) {\n        nextEl = index === radios.length - 1 ? radios[0] : radios[index + 1];\n      } // If hitting arrow up or arrow left, move to the previous radio\n      // If we're on the first radio, move to the last radio\n\n\n      if (['ArrowUp', 'ArrowLeft'].includes(ev.code)) {\n        nextEl = index === 0 ? radios[radios.length - 1] : radios[index - 1];\n      }\n\n      if (nextEl && radios.includes(nextEl)) {\n        var nextProcessed = this.processedInputs.find(function (input) {\n          return input.id === (nextEl === null || nextEl === void 0 ? void 0 : nextEl.id);\n        });\n\n        if (nextProcessed) {\n          this.rbClick(nextProcessed);\n          nextEl.focus();\n        }\n      }\n    }\n  }, {\n    key: \"buttonsChanged\",\n    value: function buttonsChanged() {\n      var buttons = this.buttons;\n      this.processedButtons = buttons.map(function (btn) {\n        return typeof btn === 'string' ? {\n          text: btn,\n          role: btn.toLowerCase() === 'cancel' ? 'cancel' : undefined\n        } : btn;\n      });\n    }\n  }, {\n    key: \"inputsChanged\",\n    value: function inputsChanged() {\n      var _this5 = this;\n\n      var inputs = this.inputs; // Get the first input that is not disabled and the checked one\n      // If an enabled checked input exists, set it to be the focusable input\n      // otherwise we default to focus the first input\n      // This will only be used when the input is type radio\n\n      var first = inputs.find(function (input) {\n        return !input.disabled;\n      });\n      var checked = inputs.find(function (input) {\n        return input.checked && !input.disabled;\n      });\n      var focusable = checked || first; // An alert can be created with several different inputs. Radios,\n      // checkboxes and inputs are all accepted, but they cannot be mixed.\n\n      var inputTypes = new Set(inputs.map(function (i) {\n        return i.type;\n      }));\n\n      if (inputTypes.has('checkbox') && inputTypes.has('radio')) {\n        console.warn(\"Alert cannot mix input types: \".concat(Array.from(inputTypes.values()).join('/'), \". Please see alert docs for more info.\"));\n      }\n\n      this.inputType = inputTypes.values().next().value;\n      this.processedInputs = inputs.map(function (i, index) {\n        return {\n          type: i.type || 'text',\n          name: i.name || \"\".concat(index),\n          placeholder: i.placeholder || '',\n          value: i.value,\n          label: i.label,\n          checked: !!i.checked,\n          disabled: !!i.disabled,\n          id: i.id || \"alert-input-\".concat(_this5.overlayIndex, \"-\").concat(index),\n          handler: i.handler,\n          min: i.min,\n          max: i.max,\n          cssClass: i.cssClass || '',\n          attributes: i.attributes || {},\n          tabindex: i.type === 'radio' && i !== focusable ? -1 : 0\n        };\n      });\n    }\n  }, {\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      prepareOverlay(this.el);\n    }\n  }, {\n    key: \"componentWillLoad\",\n    value: function componentWillLoad() {\n      this.inputsChanged();\n      this.buttonsChanged();\n    }\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      if (this.gesture) {\n        this.gesture.destroy();\n        this.gesture = undefined;\n      }\n    }\n  }, {\n    key: \"componentDidLoad\",\n    value: function componentDidLoad() {\n      /**\n       * Do not create gesture if:\n       * 1. A gesture already exists\n       * 2. App is running in MD mode\n       * 3. A wrapper ref does not exist\n       */\n      if (this.gesture || getIonMode(this) === 'md' || !this.wrapperEl) {\n        return;\n      }\n\n      this.gesture = createButtonActiveGesture(this.wrapperEl, function (refEl) {\n        return refEl.classList.contains('alert-button');\n      });\n      this.gesture.enable(true);\n    }\n    /**\n     * Present the alert overlay after it has been created.\n     */\n\n  }, {\n    key: \"present\",\n    value: function present() {\n      return _present(this, 'alertEnter', iosEnterAnimation$5, mdEnterAnimation$4);\n    }\n    /**\n     * Dismiss the alert overlay after it has been presented.\n     *\n     * @param data Any data to emit in the dismiss events.\n     * @param role The role of the element that is dismissing the alert.\n     * This can be useful in a button handler for determining which button was\n     * clicked to dismiss the alert.\n     * Some examples include: ``\"cancel\"`, `\"destructive\"`, \"selected\"`, and `\"backdrop\"`.\n     */\n\n  }, {\n    key: \"dismiss\",\n    value: function dismiss(data, role) {\n      return _dismiss(this, data, role, 'alertLeave', iosLeaveAnimation$5, mdLeaveAnimation$4);\n    }\n    /**\n     * Returns a promise that resolves when the alert did dismiss.\n     */\n\n  }, {\n    key: \"onDidDismiss\",\n    value: function onDidDismiss() {\n      return eventMethod(this.el, 'ionAlertDidDismiss');\n    }\n    /**\n     * Returns a promise that resolves when the alert will dismiss.\n     */\n\n  }, {\n    key: \"onWillDismiss\",\n    value: function onWillDismiss() {\n      return eventMethod(this.el, 'ionAlertWillDismiss');\n    }\n  }, {\n    key: \"rbClick\",\n    value: function rbClick(selectedInput) {\n      var _iterator = _createForOfIteratorHelper(this.processedInputs),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var input = _step.value;\n          input.checked = input === selectedInput;\n          input.tabindex = input === selectedInput ? 0 : -1;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.activeId = selectedInput.id;\n      safeCall(selectedInput.handler, selectedInput);\n      forceUpdate(this);\n    }\n  }, {\n    key: \"cbClick\",\n    value: function cbClick(selectedInput) {\n      selectedInput.checked = !selectedInput.checked;\n      safeCall(selectedInput.handler, selectedInput);\n      forceUpdate(this);\n    }\n  }, {\n    key: \"buttonClick\",\n    value: function buttonClick(button) {\n      var role = button.role;\n      var values = this.getValues();\n\n      if (isCancel(role)) {\n        return this.dismiss({\n          values: values\n        }, role);\n      }\n\n      var returnData = this.callButtonHandler(button, values);\n\n      if (returnData !== false) {\n        return this.dismiss(Object.assign({\n          values: values\n        }, returnData), button.role);\n      }\n\n      return Promise.resolve(false);\n    }\n  }, {\n    key: \"callButtonHandler\",\n    value: function callButtonHandler(button, data) {\n      if (button && button.handler) {\n        // a handler has been provided, execute it\n        // pass the handler the values from the inputs\n        var returnData = safeCall(button.handler, data);\n\n        if (returnData === false) {\n          // if the return value of the handler is false then do not dismiss\n          return false;\n        }\n\n        if (typeof returnData === 'object') {\n          return returnData;\n        }\n      }\n\n      return {};\n    }\n  }, {\n    key: \"getValues\",\n    value: function getValues() {\n      if (this.processedInputs.length === 0) {\n        // this is an alert without any options/inputs at all\n        return undefined;\n      }\n\n      if (this.inputType === 'radio') {\n        // this is an alert with radio buttons (single value select)\n        // return the one value which is checked, otherwise undefined\n        var checkedInput = this.processedInputs.find(function (i) {\n          return !!i.checked;\n        });\n        return checkedInput ? checkedInput.value : undefined;\n      }\n\n      if (this.inputType === 'checkbox') {\n        // this is an alert with checkboxes (multiple value select)\n        // return an array of all the checked values\n        return this.processedInputs.filter(function (i) {\n          return i.checked;\n        }).map(function (i) {\n          return i.value;\n        });\n      } // this is an alert with text inputs\n      // return an object of all the values with the input name as the key\n\n\n      var values = {};\n      this.processedInputs.forEach(function (i) {\n        values[i.name] = i.value || '';\n      });\n      return values;\n    }\n  }, {\n    key: \"renderAlertInputs\",\n    value: function renderAlertInputs() {\n      switch (this.inputType) {\n        case 'checkbox':\n          return this.renderCheckbox();\n\n        case 'radio':\n          return this.renderRadio();\n\n        default:\n          return this.renderInput();\n      }\n    }\n  }, {\n    key: \"renderCheckbox\",\n    value: function renderCheckbox() {\n      var _this6 = this;\n\n      var inputs = this.processedInputs;\n      var mode = getIonMode(this);\n\n      if (inputs.length === 0) {\n        return null;\n      }\n\n      return h(\"div\", {\n        class: \"alert-checkbox-group\"\n      }, inputs.map(function (i) {\n        return h(\"button\", {\n          type: \"button\",\n          onClick: function onClick() {\n            return _this6.cbClick(i);\n          },\n          \"aria-checked\": \"\".concat(i.checked),\n          id: i.id,\n          disabled: i.disabled,\n          tabIndex: i.tabindex,\n          role: \"checkbox\",\n          class: Object.assign(Object.assign({}, getClassMap(i.cssClass)), {\n            'alert-tappable': true,\n            'alert-checkbox': true,\n            'alert-checkbox-button': true,\n            'ion-focusable': true,\n            'alert-checkbox-button-disabled': i.disabled || false\n          })\n        }, h(\"div\", {\n          class: \"alert-button-inner\"\n        }, h(\"div\", {\n          class: \"alert-checkbox-icon\"\n        }, h(\"div\", {\n          class: \"alert-checkbox-inner\"\n        })), h(\"div\", {\n          class: \"alert-checkbox-label\"\n        }, i.label)), mode === 'md' && h(\"ion-ripple-effect\", null));\n      }));\n    }\n  }, {\n    key: \"renderRadio\",\n    value: function renderRadio() {\n      var _this7 = this;\n\n      var inputs = this.processedInputs;\n\n      if (inputs.length === 0) {\n        return null;\n      }\n\n      return h(\"div\", {\n        class: \"alert-radio-group\",\n        role: \"radiogroup\",\n        \"aria-activedescendant\": this.activeId\n      }, inputs.map(function (i) {\n        return h(\"button\", {\n          type: \"button\",\n          onClick: function onClick() {\n            return _this7.rbClick(i);\n          },\n          \"aria-checked\": \"\".concat(i.checked),\n          disabled: i.disabled,\n          id: i.id,\n          tabIndex: i.tabindex,\n          class: Object.assign(Object.assign({}, getClassMap(i.cssClass)), {\n            'alert-radio-button': true,\n            'alert-tappable': true,\n            'alert-radio': true,\n            'ion-focusable': true,\n            'alert-radio-button-disabled': i.disabled || false\n          }),\n          role: \"radio\"\n        }, h(\"div\", {\n          class: \"alert-button-inner\"\n        }, h(\"div\", {\n          class: \"alert-radio-icon\"\n        }, h(\"div\", {\n          class: \"alert-radio-inner\"\n        })), h(\"div\", {\n          class: \"alert-radio-label\"\n        }, i.label)));\n      }));\n    }\n  }, {\n    key: \"renderInput\",\n    value: function renderInput() {\n      var inputs = this.processedInputs;\n\n      if (inputs.length === 0) {\n        return null;\n      }\n\n      return h(\"div\", {\n        class: \"alert-input-group\"\n      }, inputs.map(function (i) {\n        var _a, _b, _c, _d;\n\n        if (i.type === 'textarea') {\n          return h(\"div\", {\n            class: \"alert-input-wrapper\"\n          }, h(\"textarea\", Object.assign({\n            placeholder: i.placeholder,\n            value: i.value,\n            id: i.id,\n            tabIndex: i.tabindex\n          }, i.attributes, {\n            disabled: (_b = (_a = i.attributes) === null || _a === void 0 ? void 0 : _a.disabled) !== null && _b !== void 0 ? _b : i.disabled,\n            class: inputClass(i),\n            onInput: function onInput(e) {\n              var _a;\n\n              i.value = e.target.value;\n\n              if ((_a = i.attributes) === null || _a === void 0 ? void 0 : _a.onInput) {\n                i.attributes.onInput(e);\n              }\n            }\n          })));\n        } else {\n          return h(\"div\", {\n            class: \"alert-input-wrapper\"\n          }, h(\"input\", Object.assign({\n            placeholder: i.placeholder,\n            type: i.type,\n            min: i.min,\n            max: i.max,\n            value: i.value,\n            id: i.id,\n            tabIndex: i.tabindex\n          }, i.attributes, {\n            disabled: (_d = (_c = i.attributes) === null || _c === void 0 ? void 0 : _c.disabled) !== null && _d !== void 0 ? _d : i.disabled,\n            class: inputClass(i),\n            onInput: function onInput(e) {\n              var _a;\n\n              i.value = e.target.value;\n\n              if ((_a = i.attributes) === null || _a === void 0 ? void 0 : _a.onInput) {\n                i.attributes.onInput(e);\n              }\n            }\n          })));\n        }\n      }));\n    }\n  }, {\n    key: \"renderAlertButtons\",\n    value: function renderAlertButtons() {\n      var _this8 = this;\n\n      var buttons = this.processedButtons;\n      var mode = getIonMode(this);\n      var alertButtonGroupClass = {\n        'alert-button-group': true,\n        'alert-button-group-vertical': buttons.length > 2\n      };\n      return h(\"div\", {\n        class: alertButtonGroupClass\n      }, buttons.map(function (button) {\n        return h(\"button\", {\n          type: \"button\",\n          id: button.id,\n          class: buttonClass$2(button),\n          tabIndex: 0,\n          onClick: function onClick() {\n            return _this8.buttonClick(button);\n          }\n        }, h(\"span\", {\n          class: \"alert-button-inner\"\n        }, button.text), mode === 'md' && h(\"ion-ripple-effect\", null));\n      }));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _Object$assign3,\n          _this9 = this;\n\n      var overlayIndex = this.overlayIndex,\n          header = this.header,\n          subHeader = this.subHeader,\n          htmlAttributes = this.htmlAttributes;\n      var mode = getIonMode(this);\n      var hdrId = \"alert-\".concat(overlayIndex, \"-hdr\");\n      var subHdrId = \"alert-\".concat(overlayIndex, \"-sub-hdr\");\n      var msgId = \"alert-\".concat(overlayIndex, \"-msg\");\n      var role = this.inputs.length > 0 || this.buttons.length > 0 ? 'alertdialog' : 'alert';\n      return h(Host, Object.assign({\n        role: role,\n        \"aria-modal\": \"true\",\n        tabindex: \"-1\"\n      }, htmlAttributes, {\n        style: {\n          zIndex: \"\".concat(20000 + overlayIndex)\n        },\n        class: Object.assign(Object.assign({}, getClassMap(this.cssClass)), (_Object$assign3 = {}, _defineProperty(_Object$assign3, mode, true), _defineProperty(_Object$assign3, 'overlay-hidden', true), _defineProperty(_Object$assign3, 'alert-translucent', this.translucent), _Object$assign3)),\n        onIonAlertWillDismiss: this.dispatchCancelHandler,\n        onIonBackdropTap: this.onBackdropTap\n      }), h(\"ion-backdrop\", {\n        tappable: this.backdropDismiss\n      }), h(\"div\", {\n        tabindex: \"0\"\n      }), h(\"div\", {\n        class: \"alert-wrapper ion-overlay-wrapper\",\n        ref: function ref(el) {\n          return _this9.wrapperEl = el;\n        }\n      }, h(\"div\", {\n        class: \"alert-head\"\n      }, header && h(\"h2\", {\n        id: hdrId,\n        class: \"alert-title\"\n      }, header), subHeader && h(\"h2\", {\n        id: subHdrId,\n        class: \"alert-sub-title\"\n      }, subHeader)), h(\"div\", {\n        id: msgId,\n        class: \"alert-message\",\n        innerHTML: sanitizeDOMString(this.message)\n      }), this.renderAlertInputs(), this.renderAlertButtons()), h(\"div\", {\n        tabindex: \"0\"\n      }));\n    }\n  }, {\n    key: \"el\",\n    get: function get() {\n      return getElement(this);\n    }\n  }], [{\n    key: \"watchers\",\n    get: function get() {\n      return {\n        \"buttons\": [\"buttonsChanged\"],\n        \"inputs\": [\"inputsChanged\"]\n      };\n    }\n  }]);\n\n  return Alert;\n}();\n\nvar inputClass = function inputClass(input) {\n  var _a, _b, _c;\n\n  return Object.assign(Object.assign({\n    'alert-input': true,\n    'alert-input-disabled': ((_b = (_a = input.attributes) === null || _a === void 0 ? void 0 : _a.disabled) !== null && _b !== void 0 ? _b : input.disabled) || false\n  }, getClassMap(input.cssClass)), getClassMap(input.attributes ? (_c = input.attributes.class) === null || _c === void 0 ? void 0 : _c.toString() : ''));\n};\n\nvar buttonClass$2 = function buttonClass$2(button) {\n  return Object.assign(_defineProperty({\n    'alert-button': true,\n    'ion-focusable': true,\n    'ion-activatable': true\n  }, \"alert-button-role-\".concat(button.role), button.role !== undefined), getClassMap(button.cssClass));\n};\n\nAlert.style = {\n  ios: alertIosCss,\n  md: alertMdCss\n};\n/**\n * iOS Loading Enter Animation\n */\n\nvar iosEnterAnimation$4 = function iosEnterAnimation$4(baseEl) {\n  var baseAnimation = createAnimation();\n  var backdropAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 0.01, 'var(--backdrop-opacity)').beforeStyles({\n    'pointer-events': 'none'\n  }).afterClearStyles(['pointer-events']);\n  wrapperAnimation.addElement(baseEl.querySelector('.loading-wrapper')).keyframes([{\n    offset: 0,\n    opacity: 0.01,\n    transform: 'scale(1.1)'\n  }, {\n    offset: 1,\n    opacity: 1,\n    transform: 'scale(1)'\n  }]);\n  return baseAnimation.addElement(baseEl).easing('ease-in-out').duration(200).addAnimation([backdropAnimation, wrapperAnimation]);\n};\n/**\n * iOS Loading Leave Animation\n */\n\n\nvar iosLeaveAnimation$4 = function iosLeaveAnimation$4(baseEl) {\n  var baseAnimation = createAnimation();\n  var backdropAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0);\n  wrapperAnimation.addElement(baseEl.querySelector('.loading-wrapper')).keyframes([{\n    offset: 0,\n    opacity: 0.99,\n    transform: 'scale(1)'\n  }, {\n    offset: 1,\n    opacity: 0,\n    transform: 'scale(0.9)'\n  }]);\n  return baseAnimation.addElement(baseEl).easing('ease-in-out').duration(200).addAnimation([backdropAnimation, wrapperAnimation]);\n};\n/**\n * Md Loading Enter Animation\n */\n\n\nvar mdEnterAnimation$3 = function mdEnterAnimation$3(baseEl) {\n  var baseAnimation = createAnimation();\n  var backdropAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 0.01, 'var(--backdrop-opacity)').beforeStyles({\n    'pointer-events': 'none'\n  }).afterClearStyles(['pointer-events']);\n  wrapperAnimation.addElement(baseEl.querySelector('.loading-wrapper')).keyframes([{\n    offset: 0,\n    opacity: 0.01,\n    transform: 'scale(1.1)'\n  }, {\n    offset: 1,\n    opacity: 1,\n    transform: 'scale(1)'\n  }]);\n  return baseAnimation.addElement(baseEl).easing('ease-in-out').duration(200).addAnimation([backdropAnimation, wrapperAnimation]);\n};\n/**\n * Md Loading Leave Animation\n */\n\n\nvar mdLeaveAnimation$3 = function mdLeaveAnimation$3(baseEl) {\n  var baseAnimation = createAnimation();\n  var backdropAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0);\n  wrapperAnimation.addElement(baseEl.querySelector('.loading-wrapper')).keyframes([{\n    offset: 0,\n    opacity: 0.99,\n    transform: 'scale(1)'\n  }, {\n    offset: 1,\n    opacity: 0,\n    transform: 'scale(0.9)'\n  }]);\n  return baseAnimation.addElement(baseEl).easing('ease-in-out').duration(200).addAnimation([backdropAnimation, wrapperAnimation]);\n};\n\nvar loadingIosCss = \".sc-ion-loading-ios-h{--min-width:auto;--width:auto;--min-height:auto;--height:auto;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:fixed;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;font-family:var(--ion-font-family, inherit);contain:strict;-ms-touch-action:none;touch-action:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1001}.overlay-hidden.sc-ion-loading-ios-h{display:none}.loading-wrapper.sc-ion-loading-ios{display:-ms-flexbox;display:flex;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);opacity:0;z-index:10}.spinner-lines.sc-ion-loading-ios,.spinner-lines-small.sc-ion-loading-ios,.spinner-bubbles.sc-ion-loading-ios,.spinner-circles.sc-ion-loading-ios,.spinner-crescent.sc-ion-loading-ios,.spinner-dots.sc-ion-loading-ios{color:var(--spinner-color)}.sc-ion-loading-ios-h{--background:var(--ion-overlay-background-color, var(--ion-color-step-100, #f9f9f9));--max-width:270px;--max-height:90%;--spinner-color:var(--ion-color-step-600, #666666);--backdrop-opacity:var(--ion-backdrop-opacity, 0.3);color:var(--ion-text-color, #000);font-size:14px}.loading-wrapper.sc-ion-loading-ios{border-radius:8px;padding-left:34px;padding-right:34px;padding-top:24px;padding-bottom:24px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.loading-wrapper.sc-ion-loading-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:34px;padding-inline-start:34px;-webkit-padding-end:34px;padding-inline-end:34px}}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){.loading-translucent.sc-ion-loading-ios-h .loading-wrapper.sc-ion-loading-ios{background-color:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8);-webkit-backdrop-filter:saturate(180%) blur(20px);backdrop-filter:saturate(180%) blur(20px)}}.loading-content.sc-ion-loading-ios{font-weight:bold}.loading-spinner.sc-ion-loading-ios+.loading-content.sc-ion-loading-ios{margin-left:16px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.loading-spinner.sc-ion-loading-ios+.loading-content.sc-ion-loading-ios{margin-left:unset;-webkit-margin-start:16px;margin-inline-start:16px}}\";\nvar loadingMdCss = \".sc-ion-loading-md-h{--min-width:auto;--width:auto;--min-height:auto;--height:auto;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:fixed;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;font-family:var(--ion-font-family, inherit);contain:strict;-ms-touch-action:none;touch-action:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1001}.overlay-hidden.sc-ion-loading-md-h{display:none}.loading-wrapper.sc-ion-loading-md{display:-ms-flexbox;display:flex;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);opacity:0;z-index:10}.spinner-lines.sc-ion-loading-md,.spinner-lines-small.sc-ion-loading-md,.spinner-bubbles.sc-ion-loading-md,.spinner-circles.sc-ion-loading-md,.spinner-crescent.sc-ion-loading-md,.spinner-dots.sc-ion-loading-md{color:var(--spinner-color)}.sc-ion-loading-md-h{--background:var(--ion-color-step-50, #f2f2f2);--max-width:280px;--max-height:90%;--spinner-color:var(--ion-color-primary, #3880ff);--backdrop-opacity:var(--ion-backdrop-opacity, 0.32);color:var(--ion-color-step-850, #262626);font-size:14px}.loading-wrapper.sc-ion-loading-md{border-radius:2px;padding-left:24px;padding-right:24px;padding-top:24px;padding-bottom:24px;-webkit-box-shadow:0 16px 20px rgba(0, 0, 0, 0.4);box-shadow:0 16px 20px rgba(0, 0, 0, 0.4)}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.loading-wrapper.sc-ion-loading-md{padding-left:unset;padding-right:unset;-webkit-padding-start:24px;padding-inline-start:24px;-webkit-padding-end:24px;padding-inline-end:24px}}.loading-spinner.sc-ion-loading-md+.loading-content.sc-ion-loading-md{margin-left:16px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.loading-spinner.sc-ion-loading-md+.loading-content.sc-ion-loading-md{margin-left:unset;-webkit-margin-start:16px;margin-inline-start:16px}}\";\n\nvar Loading = /*#__PURE__*/function () {\n  function Loading(hostRef) {\n    var _this10 = this;\n\n    _classCallCheck(this, Loading);\n\n    registerInstance(this, hostRef);\n    this.didPresent = createEvent(this, \"ionLoadingDidPresent\", 7);\n    this.willPresent = createEvent(this, \"ionLoadingWillPresent\", 7);\n    this.willDismiss = createEvent(this, \"ionLoadingWillDismiss\", 7);\n    this.didDismiss = createEvent(this, \"ionLoadingDidDismiss\", 7);\n    this.presented = false;\n    /**\n     * If `true`, the keyboard will be automatically dismissed when the overlay is presented.\n     */\n\n    this.keyboardClose = true;\n    /**\n     * Number of milliseconds to wait before dismissing the loading indicator.\n     */\n\n    this.duration = 0;\n    /**\n     * If `true`, the loading indicator will be dismissed when the backdrop is clicked.\n     */\n\n    this.backdropDismiss = false;\n    /**\n     * If `true`, a backdrop will be displayed behind the loading indicator.\n     */\n\n    this.showBackdrop = true;\n    /**\n     * If `true`, the loading indicator will be translucent.\n     * Only applies when the mode is `\"ios\"` and the device supports\n     * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).\n     */\n\n    this.translucent = false;\n    /**\n     * If `true`, the loading indicator will animate.\n     */\n\n    this.animated = true;\n\n    this.onBackdropTap = function () {\n      _this10.dismiss(undefined, BACKDROP);\n    };\n  }\n\n  _createClass(Loading, [{\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      prepareOverlay(this.el);\n    }\n  }, {\n    key: \"componentWillLoad\",\n    value: function componentWillLoad() {\n      if (this.spinner === undefined) {\n        var mode = getIonMode(this);\n        this.spinner = config.get('loadingSpinner', config.get('spinner', mode === 'ios' ? 'lines' : 'crescent'));\n      }\n    }\n    /**\n     * Present the loading overlay after it has been created.\n     */\n\n  }, {\n    key: \"present\",\n    value: function () {\n      var _present2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this11 = this;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return _present(this, 'loadingEnter', iosEnterAnimation$4, mdEnterAnimation$3, undefined);\n\n              case 2:\n                if (this.duration > 0) {\n                  this.durationTimeout = setTimeout(function () {\n                    return _this11.dismiss();\n                  }, this.duration + 10);\n                }\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function present() {\n        return _present2.apply(this, arguments);\n      }\n\n      return present;\n    }()\n    /**\n     * Dismiss the loading overlay after it has been presented.\n     *\n     * @param data Any data to emit in the dismiss events.\n     * @param role The role of the element that is dismissing the loading.\n     * This can be useful in a button handler for determining which button was\n     * clicked to dismiss the loading.\n     * Some examples include: ``\"cancel\"`, `\"destructive\"`, \"selected\"`, and `\"backdrop\"`.\n     */\n\n  }, {\n    key: \"dismiss\",\n    value: function dismiss(data, role) {\n      if (this.durationTimeout) {\n        clearTimeout(this.durationTimeout);\n      }\n\n      return _dismiss(this, data, role, 'loadingLeave', iosLeaveAnimation$4, mdLeaveAnimation$3);\n    }\n    /**\n     * Returns a promise that resolves when the loading did dismiss.\n     */\n\n  }, {\n    key: \"onDidDismiss\",\n    value: function onDidDismiss() {\n      return eventMethod(this.el, 'ionLoadingDidDismiss');\n    }\n    /**\n     * Returns a promise that resolves when the loading will dismiss.\n     */\n\n  }, {\n    key: \"onWillDismiss\",\n    value: function onWillDismiss() {\n      return eventMethod(this.el, 'ionLoadingWillDismiss');\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _Object$assign5;\n\n      var message = this.message,\n          spinner = this.spinner,\n          htmlAttributes = this.htmlAttributes;\n      var mode = getIonMode(this);\n      return h(Host, Object.assign({\n        tabindex: \"-1\"\n      }, htmlAttributes, {\n        style: {\n          zIndex: \"\".concat(40000 + this.overlayIndex)\n        },\n        onIonBackdropTap: this.onBackdropTap,\n        class: Object.assign(Object.assign({}, getClassMap(this.cssClass)), (_Object$assign5 = {}, _defineProperty(_Object$assign5, mode, true), _defineProperty(_Object$assign5, 'overlay-hidden', true), _defineProperty(_Object$assign5, 'loading-translucent', this.translucent), _Object$assign5))\n      }), h(\"ion-backdrop\", {\n        visible: this.showBackdrop,\n        tappable: this.backdropDismiss\n      }), h(\"div\", {\n        tabindex: \"0\"\n      }), h(\"div\", {\n        class: \"loading-wrapper ion-overlay-wrapper\",\n        role: \"dialog\"\n      }, spinner && h(\"div\", {\n        class: \"loading-spinner\"\n      }, h(\"ion-spinner\", {\n        name: spinner,\n        \"aria-hidden\": \"true\"\n      })), message && h(\"div\", {\n        class: \"loading-content\",\n        innerHTML: sanitizeDOMString(message)\n      })), h(\"div\", {\n        tabindex: \"0\"\n      }));\n    }\n  }, {\n    key: \"el\",\n    get: function get() {\n      return getElement(this);\n    }\n  }]);\n\n  return Loading;\n}();\n\nLoading.style = {\n  ios: loadingIosCss,\n  md: loadingMdCss\n}; // Defaults for the card swipe animation\n\nvar SwipeToCloseDefaults = {\n  MIN_PRESENTING_SCALE: 0.93\n};\n\nvar createSwipeToCloseGesture = function createSwipeToCloseGesture(el, animation, onDismiss) {\n  var height = el.offsetHeight;\n  var isOpen = false;\n\n  var canStart = function canStart(detail) {\n    var target = detail.event.target;\n\n    if (target === null || !target.closest) {\n      return true;\n    }\n\n    var contentOrFooter = target.closest('ion-content, ion-footer');\n\n    if (contentOrFooter === null) {\n      return true;\n    } // Target is in the content or the footer so do not start the gesture.\n    // We could be more nuanced here and allow it for content that\n    // does not need to scroll.\n\n\n    return false;\n  };\n\n  var onStart = function onStart() {\n    animation.progressStart(true, isOpen ? 1 : 0);\n  };\n\n  var onMove = function onMove(detail) {\n    var step = clamp(0.0001, detail.deltaY / height, 0.9999);\n    animation.progressStep(step);\n  };\n\n  var onEnd = function onEnd(detail) {\n    var velocity = detail.velocityY;\n    var step = clamp(0.0001, detail.deltaY / height, 0.9999);\n    var threshold = (detail.deltaY + velocity * 1000) / height;\n    var shouldComplete = threshold >= 0.5;\n    var newStepValue = shouldComplete ? -0.001 : 0.001;\n\n    if (!shouldComplete) {\n      animation.easing('cubic-bezier(1, 0, 0.68, 0.28)');\n      newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], step)[0];\n    } else {\n      animation.easing('cubic-bezier(0.32, 0.72, 0, 1)');\n      newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], step)[0];\n    }\n\n    var duration = shouldComplete ? computeDuration(step * height, velocity) : computeDuration((1 - step) * height, velocity);\n    isOpen = shouldComplete;\n    gesture.enable(false);\n    animation.onFinish(function () {\n      if (!shouldComplete) {\n        gesture.enable(true);\n      }\n    }).progressEnd(shouldComplete ? 1 : 0, newStepValue, duration);\n\n    if (shouldComplete) {\n      onDismiss();\n    }\n  };\n\n  var gesture = createGesture({\n    el: el,\n    gestureName: 'modalSwipeToClose',\n    gesturePriority: 40,\n    direction: 'y',\n    threshold: 10,\n    canStart: canStart,\n    onStart: onStart,\n    onMove: onMove,\n    onEnd: onEnd\n  });\n  return gesture;\n};\n\nvar computeDuration = function computeDuration(remaining, velocity) {\n  return clamp(400, remaining / Math.abs(velocity * 1.1), 500);\n};\n/**\n * Use y = mx + b to\n * figure out the backdrop value\n * at a particular x coordinate. This\n * is useful when the backdrop does\n * not begin to fade in until after\n * the 0 breakpoint.\n */\n\n\nvar getBackdropValueForSheet = function getBackdropValueForSheet(x, backdropBreakpoint) {\n  /**\n   * We will use these points:\n   * (backdropBreakpoint, 0)\n   * (maxBreakpoint, 1)\n   * We know that at the beginning breakpoint,\n   * the backdrop will be hidden. We also\n   * know that at the maxBreakpoint, the backdrop\n   * must be fully visible. maxBreakpoint should\n   * always be 1 even if the maximum value\n   * of the breakpoints array is not 1 since\n   * the animation runs from a progress of 0\n   * to a progress of 1.\n   * m = (y2 - y1) / (x2 - x1)\n   *\n   * This is simplified from:\n   * m = (1 - 0) / (maxBreakpoint - backdropBreakpoint)\n   */\n  var slope = 1 / (1 - backdropBreakpoint);\n  /**\n   * From here, compute b which is\n   * the backdrop opacity if the offset\n   * is 0. If the backdrop does not\n   * begin to fade in until after the\n   * 0 breakpoint, this b value will be\n   * negative. This is fine as we never pass\n   * b directly into the animation keyframes.\n   * b = y - mx\n   * Use a known point: (backdropBreakpoint, 0)\n   * This is simplified from:\n   * b = 0 - (backdropBreakpoint * slope)\n   */\n\n  var b = -(backdropBreakpoint * slope);\n  /**\n   * Finally, we can now determine the\n   * backdrop offset given an arbitrary\n   * gesture offset.\n   */\n\n  return x * slope + b;\n};\n\nvar createSheetEnterAnimation = function createSheetEnterAnimation(opts) {\n  var currentBreakpoint = opts.currentBreakpoint,\n      backdropBreakpoint = opts.backdropBreakpoint;\n  /**\n   * If the backdropBreakpoint is undefined, then the backdrop\n   * should always fade in. If the backdropBreakpoint came before the\n   * current breakpoint, then the backdrop should be fading in.\n   */\n\n  var shouldShowBackdrop = backdropBreakpoint === undefined || backdropBreakpoint < currentBreakpoint;\n  var initialBackdrop = shouldShowBackdrop ? \"calc(var(--backdrop-opacity) * \".concat(currentBreakpoint, \")\") : '0';\n  var backdropAnimation = createAnimation('backdropAnimation').fromTo('opacity', 0, initialBackdrop);\n  var wrapperAnimation = createAnimation('wrapperAnimation').keyframes([{\n    offset: 0,\n    opacity: 1,\n    transform: 'translateY(100%)'\n  }, {\n    offset: 1,\n    opacity: 1,\n    transform: \"translateY(\".concat(100 - currentBreakpoint * 100, \"%)\")\n  }]);\n  return {\n    wrapperAnimation: wrapperAnimation,\n    backdropAnimation: backdropAnimation\n  };\n};\n\nvar createSheetLeaveAnimation = function createSheetLeaveAnimation(opts) {\n  var currentBreakpoint = opts.currentBreakpoint,\n      backdropBreakpoint = opts.backdropBreakpoint;\n  /**\n   * Backdrop does not always fade in from 0 to 1 if backdropBreakpoint\n   * is defined, so we need to account for that offset by figuring out\n   * what the current backdrop value should be.\n   */\n\n  var backdropValue = \"calc(var(--backdrop-opacity) * \".concat(getBackdropValueForSheet(currentBreakpoint, backdropBreakpoint), \")\");\n  var defaultBackdrop = [{\n    offset: 0,\n    opacity: backdropValue\n  }, {\n    offset: 1,\n    opacity: 0\n  }];\n  var customBackdrop = [{\n    offset: 0,\n    opacity: backdropValue\n  }, {\n    offset: backdropBreakpoint,\n    opacity: 0\n  }, {\n    offset: 1,\n    opacity: 0\n  }];\n  var backdropAnimation = createAnimation('backdropAnimation').keyframes(backdropBreakpoint !== 0 ? customBackdrop : defaultBackdrop);\n  var wrapperAnimation = createAnimation('wrapperAnimation').keyframes([{\n    offset: 0,\n    opacity: 1,\n    transform: \"translateY(\".concat(100 - currentBreakpoint * 100, \"%)\")\n  }, {\n    offset: 1,\n    opacity: 1,\n    transform: \"translateY(100%)\"\n  }]);\n  return {\n    wrapperAnimation: wrapperAnimation,\n    backdropAnimation: backdropAnimation\n  };\n};\n\nvar createEnterAnimation$1 = function createEnterAnimation$1() {\n  var backdropAnimation = createAnimation().fromTo('opacity', 0.01, 'var(--backdrop-opacity)');\n  var wrapperAnimation = createAnimation().fromTo('transform', 'translateY(100vh)', 'translateY(0vh)');\n  return {\n    backdropAnimation: backdropAnimation,\n    wrapperAnimation: wrapperAnimation\n  };\n};\n/**\n * iOS Modal Enter Animation for the Card presentation style\n */\n\n\nvar iosEnterAnimation$3 = function iosEnterAnimation$3(baseEl, opts) {\n  var presentingEl = opts.presentingEl,\n      currentBreakpoint = opts.currentBreakpoint;\n  var root = getElementRoot(baseEl);\n\n  var _ref = currentBreakpoint !== undefined ? createSheetEnterAnimation(opts) : createEnterAnimation$1(),\n      wrapperAnimation = _ref.wrapperAnimation,\n      backdropAnimation = _ref.backdropAnimation;\n\n  backdropAnimation.addElement(root.querySelector('ion-backdrop')).beforeStyles({\n    'pointer-events': 'none'\n  }).afterClearStyles(['pointer-events']);\n  wrapperAnimation.addElement(root.querySelectorAll('.modal-wrapper, .modal-shadow')).beforeStyles({\n    'opacity': 1\n  });\n  var baseAnimation = createAnimation('entering-base').addElement(baseEl).easing('cubic-bezier(0.32,0.72,0,1)').duration(500).addAnimation(wrapperAnimation);\n\n  if (presentingEl) {\n    var isMobile = window.innerWidth < 768;\n    var hasCardModal = presentingEl.tagName === 'ION-MODAL' && presentingEl.presentingElement !== undefined;\n    var presentingElRoot = getElementRoot(presentingEl);\n    var presentingAnimation = createAnimation().beforeStyles({\n      'transform': 'translateY(0)',\n      'transform-origin': 'top center',\n      'overflow': 'hidden'\n    });\n    var bodyEl = document.body;\n\n    if (isMobile) {\n      /**\n       * Fallback for browsers that does not support `max()` (ex: Firefox)\n       * No need to worry about statusbar padding since engines like Gecko\n       * are not used as the engine for standalone Cordova/Capacitor apps\n       */\n      var transformOffset = !CSS.supports('width', 'max(0px, 1px)') ? '30px' : 'max(30px, var(--ion-safe-area-top))';\n      var modalTransform = hasCardModal ? '-10px' : transformOffset;\n      var toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;\n      var finalTransform = \"translateY(\".concat(modalTransform, \") scale(\").concat(toPresentingScale, \")\");\n      presentingAnimation.afterStyles({\n        'transform': finalTransform\n      }).beforeAddWrite(function () {\n        return bodyEl.style.setProperty('background-color', 'black');\n      }).addElement(presentingEl).keyframes([{\n        offset: 0,\n        filter: 'contrast(1)',\n        transform: 'translateY(0px) scale(1)',\n        borderRadius: '0px'\n      }, {\n        offset: 1,\n        filter: 'contrast(0.85)',\n        transform: finalTransform,\n        borderRadius: '10px 10px 0 0'\n      }]);\n      baseAnimation.addAnimation(presentingAnimation);\n    } else {\n      baseAnimation.addAnimation(backdropAnimation);\n\n      if (!hasCardModal) {\n        wrapperAnimation.fromTo('opacity', '0', '1');\n      } else {\n        var _toPresentingScale = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;\n\n        var _finalTransform = \"translateY(-10px) scale(\".concat(_toPresentingScale, \")\");\n\n        presentingAnimation.afterStyles({\n          'transform': _finalTransform\n        }).addElement(presentingElRoot.querySelector('.modal-wrapper')).keyframes([{\n          offset: 0,\n          filter: 'contrast(1)',\n          transform: 'translateY(0) scale(1)'\n        }, {\n          offset: 1,\n          filter: 'contrast(0.85)',\n          transform: _finalTransform\n        }]);\n        var shadowAnimation = createAnimation().afterStyles({\n          'transform': _finalTransform\n        }).addElement(presentingElRoot.querySelector('.modal-shadow')).keyframes([{\n          offset: 0,\n          opacity: '1',\n          transform: 'translateY(0) scale(1)'\n        }, {\n          offset: 1,\n          opacity: '0',\n          transform: _finalTransform\n        }]);\n        baseAnimation.addAnimation([presentingAnimation, shadowAnimation]);\n      }\n    }\n  } else {\n    baseAnimation.addAnimation(backdropAnimation);\n  }\n\n  return baseAnimation;\n};\n\nvar createLeaveAnimation$1 = function createLeaveAnimation$1() {\n  var backdropAnimation = createAnimation().fromTo('opacity', 'var(--backdrop-opacity)', 0);\n  var wrapperAnimation = createAnimation().fromTo('transform', 'translateY(0vh)', 'translateY(100vh)');\n  return {\n    backdropAnimation: backdropAnimation,\n    wrapperAnimation: wrapperAnimation\n  };\n};\n/**\n * iOS Modal Leave Animation\n */\n\n\nvar iosLeaveAnimation$3 = function iosLeaveAnimation$3(baseEl, opts) {\n  var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 500;\n  var presentingEl = opts.presentingEl,\n      currentBreakpoint = opts.currentBreakpoint;\n  var root = getElementRoot(baseEl);\n\n  var _ref2 = currentBreakpoint !== undefined ? createSheetLeaveAnimation(opts) : createLeaveAnimation$1(),\n      wrapperAnimation = _ref2.wrapperAnimation,\n      backdropAnimation = _ref2.backdropAnimation;\n\n  backdropAnimation.addElement(root.querySelector('ion-backdrop'));\n  wrapperAnimation.addElement(root.querySelectorAll('.modal-wrapper, .modal-shadow')).beforeStyles({\n    'opacity': 1\n  });\n  var baseAnimation = createAnimation('leaving-base').addElement(baseEl).easing('cubic-bezier(0.32,0.72,0,1)').duration(duration).addAnimation(wrapperAnimation);\n\n  if (presentingEl) {\n    var isMobile = window.innerWidth < 768;\n    var hasCardModal = presentingEl.tagName === 'ION-MODAL' && presentingEl.presentingElement !== undefined;\n    var presentingElRoot = getElementRoot(presentingEl);\n    var presentingAnimation = createAnimation().beforeClearStyles(['transform']).afterClearStyles(['transform']).onFinish(function (currentStep) {\n      // only reset background color if this is the last card-style modal\n      if (currentStep !== 1) {\n        return;\n      }\n\n      presentingEl.style.setProperty('overflow', '');\n      var numModals = Array.from(bodyEl.querySelectorAll('ion-modal')).filter(function (m) {\n        return m.presentingElement !== undefined;\n      }).length;\n\n      if (numModals <= 1) {\n        bodyEl.style.setProperty('background-color', '');\n      }\n    });\n    var bodyEl = document.body;\n\n    if (isMobile) {\n      var transformOffset = !CSS.supports('width', 'max(0px, 1px)') ? '30px' : 'max(30px, var(--ion-safe-area-top))';\n      var modalTransform = hasCardModal ? '-10px' : transformOffset;\n      var toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;\n      var finalTransform = \"translateY(\".concat(modalTransform, \") scale(\").concat(toPresentingScale, \")\");\n      presentingAnimation.addElement(presentingEl).keyframes([{\n        offset: 0,\n        filter: 'contrast(0.85)',\n        transform: finalTransform,\n        borderRadius: '10px 10px 0 0'\n      }, {\n        offset: 1,\n        filter: 'contrast(1)',\n        transform: 'translateY(0px) scale(1)',\n        borderRadius: '0px'\n      }]);\n      baseAnimation.addAnimation(presentingAnimation);\n    } else {\n      baseAnimation.addAnimation(backdropAnimation);\n\n      if (!hasCardModal) {\n        wrapperAnimation.fromTo('opacity', '1', '0');\n      } else {\n        var _toPresentingScale2 = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;\n\n        var _finalTransform2 = \"translateY(-10px) scale(\".concat(_toPresentingScale2, \")\");\n\n        presentingAnimation.addElement(presentingElRoot.querySelector('.modal-wrapper')).afterStyles({\n          'transform': 'translate3d(0, 0, 0)'\n        }).keyframes([{\n          offset: 0,\n          filter: 'contrast(0.85)',\n          transform: _finalTransform2\n        }, {\n          offset: 1,\n          filter: 'contrast(1)',\n          transform: 'translateY(0) scale(1)'\n        }]);\n        var shadowAnimation = createAnimation().addElement(presentingElRoot.querySelector('.modal-shadow')).afterStyles({\n          'transform': 'translateY(0) scale(1)'\n        }).keyframes([{\n          offset: 0,\n          opacity: '0',\n          transform: _finalTransform2\n        }, {\n          offset: 1,\n          opacity: '1',\n          transform: 'translateY(0) scale(1)'\n        }]);\n        baseAnimation.addAnimation([presentingAnimation, shadowAnimation]);\n      }\n    }\n  } else {\n    baseAnimation.addAnimation(backdropAnimation);\n  }\n\n  return baseAnimation;\n};\n\nvar createEnterAnimation = function createEnterAnimation() {\n  var backdropAnimation = createAnimation().fromTo('opacity', 0.01, 'var(--backdrop-opacity)');\n  var wrapperAnimation = createAnimation().keyframes([{\n    offset: 0,\n    opacity: 0.01,\n    transform: 'translateY(40px)'\n  }, {\n    offset: 1,\n    opacity: 1,\n    transform: \"translateY(0px)\"\n  }]);\n  return {\n    backdropAnimation: backdropAnimation,\n    wrapperAnimation: wrapperAnimation\n  };\n};\n/**\n * Md Modal Enter Animation\n */\n\n\nvar mdEnterAnimation$2 = function mdEnterAnimation$2(baseEl, opts) {\n  var currentBreakpoint = opts.currentBreakpoint;\n  var root = getElementRoot(baseEl);\n\n  var _ref3 = currentBreakpoint !== undefined ? createSheetEnterAnimation(opts) : createEnterAnimation(),\n      wrapperAnimation = _ref3.wrapperAnimation,\n      backdropAnimation = _ref3.backdropAnimation;\n\n  backdropAnimation.addElement(root.querySelector('ion-backdrop')).beforeStyles({\n    'pointer-events': 'none'\n  }).afterClearStyles(['pointer-events']);\n  wrapperAnimation.addElement(root.querySelector('.modal-wrapper'));\n  return createAnimation().addElement(baseEl).easing('cubic-bezier(0.36,0.66,0.04,1)').duration(280).addAnimation([backdropAnimation, wrapperAnimation]);\n};\n\nvar createLeaveAnimation = function createLeaveAnimation() {\n  var backdropAnimation = createAnimation().fromTo('opacity', 'var(--backdrop-opacity)', 0);\n  var wrapperAnimation = createAnimation().keyframes([{\n    offset: 0,\n    opacity: 0.99,\n    transform: \"translateY(0px)\"\n  }, {\n    offset: 1,\n    opacity: 0,\n    transform: 'translateY(40px)'\n  }]);\n  return {\n    backdropAnimation: backdropAnimation,\n    wrapperAnimation: wrapperAnimation\n  };\n};\n/**\n * Md Modal Leave Animation\n */\n\n\nvar mdLeaveAnimation$2 = function mdLeaveAnimation$2(baseEl, opts) {\n  var currentBreakpoint = opts.currentBreakpoint;\n  var root = getElementRoot(baseEl);\n\n  var _ref4 = currentBreakpoint !== undefined ? createSheetLeaveAnimation(opts) : createLeaveAnimation(),\n      wrapperAnimation = _ref4.wrapperAnimation,\n      backdropAnimation = _ref4.backdropAnimation;\n\n  backdropAnimation.addElement(root.querySelector('ion-backdrop'));\n  wrapperAnimation.addElement(root.querySelector('.modal-wrapper'));\n  return createAnimation().easing('cubic-bezier(0.47,0,0.745,0.715)').duration(200).addAnimation([backdropAnimation, wrapperAnimation]);\n};\n\nvar createSheetGesture = function createSheetGesture(baseEl, backdropEl, wrapperEl, initialBreakpoint, backdropBreakpoint, animation) {\n  var breakpoints = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];\n  var onDismiss = arguments.length > 7 ? arguments[7] : undefined;\n  var onBreakpointChange = arguments.length > 8 ? arguments[8] : undefined;\n  // Defaults for the sheet swipe animation\n  var defaultBackdrop = [{\n    offset: 0,\n    opacity: 'var(--backdrop-opacity)'\n  }, {\n    offset: 1,\n    opacity: 0.01\n  }];\n  var customBackdrop = [{\n    offset: 0,\n    opacity: 'var(--backdrop-opacity)'\n  }, {\n    offset: 1 - backdropBreakpoint,\n    opacity: 0\n  }, {\n    offset: 1,\n    opacity: 0\n  }];\n  var SheetDefaults = {\n    WRAPPER_KEYFRAMES: [{\n      offset: 0,\n      transform: 'translateY(0%)'\n    }, {\n      offset: 1,\n      transform: 'translateY(100%)'\n    }],\n    BACKDROP_KEYFRAMES: backdropBreakpoint !== 0 ? customBackdrop : defaultBackdrop\n  };\n  var contentEl = baseEl.querySelector('ion-content');\n  var height = wrapperEl.clientHeight;\n  var currentBreakpoint = initialBreakpoint;\n  var offset = 0;\n  var wrapperAnimation = animation.childAnimations.find(function (ani) {\n    return ani.id === 'wrapperAnimation';\n  });\n  var backdropAnimation = animation.childAnimations.find(function (ani) {\n    return ani.id === 'backdropAnimation';\n  });\n  var maxBreakpoint = breakpoints[breakpoints.length - 1];\n  /**\n   * After the entering animation completes,\n   * we need to set the animation to go from\n   * offset 0 to offset 1 so that users can\n   * swipe in any direction. We then set the\n   * animation offset to the current breakpoint\n   * so there is no flickering.\n   */\n\n  if (wrapperAnimation && backdropAnimation) {\n    wrapperAnimation.keyframes(_toConsumableArray(SheetDefaults.WRAPPER_KEYFRAMES));\n    backdropAnimation.keyframes(_toConsumableArray(SheetDefaults.BACKDROP_KEYFRAMES));\n    animation.progressStart(true, 1 - currentBreakpoint);\n    /**\n     * Backdrop should become enabled\n     * after the backdropBreakpoint value\n     */\n\n    var backdropEnabled = currentBreakpoint > backdropBreakpoint;\n    backdropEl.style.setProperty('pointer-events', backdropEnabled ? 'auto' : 'none');\n  }\n\n  if (contentEl && currentBreakpoint !== maxBreakpoint) {\n    contentEl.scrollY = false;\n  }\n\n  var canStart = function canStart(detail) {\n    /**\n     * If the sheet is fully expanded and\n     * the user is swiping on the content,\n     * the gesture should not start to\n     * allow for scrolling on the content.\n     */\n    var content = detail.event.target.closest('ion-content');\n\n    if (currentBreakpoint === 1 && content) {\n      return false;\n    }\n\n    return true;\n  };\n\n  var onStart = function onStart() {\n    /**\n     * If swiping on the content\n     * we should disable scrolling otherwise\n     * the sheet will expand and the content will scroll.\n     */\n    if (contentEl) {\n      contentEl.scrollY = false;\n    }\n\n    raf(function () {\n      /**\n       * Dismisses the open keyboard when the sheet drag gesture is started.\n       * Sets the focus onto the modal element.\n       */\n      baseEl.focus();\n    });\n    animation.progressStart(true, 1 - currentBreakpoint);\n  };\n\n  var onMove = function onMove(detail) {\n    /**\n     * Given the change in gesture position on the Y axis,\n     * compute where the offset of the animation should be\n     * relative to where the user dragged.\n     */\n    var initialStep = 1 - currentBreakpoint;\n    offset = clamp(0.0001, initialStep + detail.deltaY / height, 0.9999);\n    animation.progressStep(offset);\n  };\n\n  var onEnd = function onEnd(detail) {\n    /**\n     * When the gesture releases, we need to determine\n     * the closest breakpoint to snap to.\n     */\n    var velocity = detail.velocityY;\n    var threshold = (detail.deltaY + velocity * 100) / height;\n    var diff = currentBreakpoint - threshold;\n    var closest = breakpoints.reduce(function (a, b) {\n      return Math.abs(b - diff) < Math.abs(a - diff) ? b : a;\n    });\n    var shouldRemainOpen = closest !== 0;\n    currentBreakpoint = 0;\n    /**\n     * Update the animation so that it plays from\n     * the last offset to the closest snap point.\n     */\n\n    if (wrapperAnimation && backdropAnimation) {\n      wrapperAnimation.keyframes([{\n        offset: 0,\n        transform: \"translateY(\".concat(offset * 100, \"%)\")\n      }, {\n        offset: 1,\n        transform: \"translateY(\".concat((1 - closest) * 100, \"%)\")\n      }]);\n      backdropAnimation.keyframes([{\n        offset: 0,\n        opacity: \"calc(var(--backdrop-opacity) * \".concat(getBackdropValueForSheet(1 - offset, backdropBreakpoint), \")\")\n      }, {\n        offset: 1,\n        opacity: \"calc(var(--backdrop-opacity) * \".concat(getBackdropValueForSheet(closest, backdropBreakpoint), \")\")\n      }]);\n      animation.progressStep(0);\n    }\n    /**\n     * Gesture should remain disabled until the\n     * snapping animation completes.\n     */\n\n\n    gesture.enable(false);\n    animation.onFinish(function () {\n      if (shouldRemainOpen) {\n        /**\n         * Once the snapping animation completes,\n         * we need to reset the animation to go\n         * from 0 to 1 so users can swipe in any direction.\n         * We then set the animation offset to the current\n         * breakpoint so that it starts at the snapped position.\n         */\n        if (wrapperAnimation && backdropAnimation) {\n          raf(function () {\n            wrapperAnimation.keyframes(_toConsumableArray(SheetDefaults.WRAPPER_KEYFRAMES));\n            backdropAnimation.keyframes(_toConsumableArray(SheetDefaults.BACKDROP_KEYFRAMES));\n            animation.progressStart(true, 1 - closest);\n            currentBreakpoint = closest;\n            onBreakpointChange(currentBreakpoint);\n            /**\n             * If the sheet is fully expanded, we can safely\n             * enable scrolling again.\n             */\n\n            if (contentEl && currentBreakpoint === breakpoints[breakpoints.length - 1]) {\n              contentEl.scrollY = true;\n            }\n            /**\n             * Backdrop should become enabled\n             * after the backdropBreakpoint value\n             */\n\n\n            var backdropEnabled = currentBreakpoint > backdropBreakpoint;\n            backdropEl.style.setProperty('pointer-events', backdropEnabled ? 'auto' : 'none');\n            gesture.enable(true);\n          });\n        } else {\n          gesture.enable(true);\n        }\n      }\n      /**\n       * This must be a one time callback\n       * otherwise a new callback will\n       * be added every time onEnd runs.\n       */\n\n    }, {\n      oneTimeCallback: true\n    }).progressEnd(1, 0, 500);\n\n    if (!shouldRemainOpen) {\n      onDismiss();\n    }\n  };\n\n  var gesture = createGesture({\n    el: wrapperEl,\n    gestureName: 'modalSheet',\n    gesturePriority: 40,\n    direction: 'y',\n    threshold: 10,\n    canStart: canStart,\n    onStart: onStart,\n    onMove: onMove,\n    onEnd: onEnd\n  });\n  return gesture;\n};\n\nvar modalIosCss = \":host{--width:100%;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--overflow:hidden;--border-radius:0;--border-width:0;--border-style:none;--border-color:transparent;--background:var(--ion-background-color, #fff);--box-shadow:none;--backdrop-opacity:0;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;contain:strict;pointer-events:none}:host(.modal-interactive) .modal-wrapper,:host(.modal-interactive) ion-backdrop{pointer-events:auto}:host(.overlay-hidden){display:none}.modal-wrapper,.modal-shadow{border-radius:var(--border-radius);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:var(--overflow);z-index:10}.modal-shadow{position:absolute;background:transparent}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--width:600px;--height:500px;--ion-safe-area-top:0px;--ion-safe-area-bottom:0px;--ion-safe-area-right:0px;--ion-safe-area-left:0px}}@media only screen and (min-width: 768px) and (min-height: 768px){:host{--width:600px;--height:600px}}.modal-handle{left:0px;right:0px;top:5px;border-radius:8px;margin-left:auto;margin-right:auto;position:absolute;width:36px;height:5px;-webkit-transform:translateZ(0);transform:translateZ(0);background:var(--ion-color-step-350, #c0c0be);z-index:11}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.modal-handle{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}:host(.modal-sheet){--height:calc(100% - (var(--ion-safe-area-top) + 10px))}:host(.modal-sheet) .modal-wrapper,:host(.modal-sheet) .modal-shadow{position:absolute;bottom:0}:host{--backdrop-opacity:var(--ion-backdrop-opacity, 0.4)}:host(.modal-card),:host(.modal-sheet){--border-radius:10px}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--border-radius:10px}}.modal-wrapper{-webkit-transform:translate3d(0,  100%,  0);transform:translate3d(0,  100%,  0)}@media screen and (max-width: 767px){@supports (width: max(0px, 1px)){:host(.modal-card){--height:calc(100% - max(30px, var(--ion-safe-area-top)) - 10px)}}@supports not (width: max(0px, 1px)){:host(.modal-card){--height:calc(100% - 40px)}}:host(.modal-card) .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl]):host(.modal-card) .modal-wrapper,:host-context([dir=rtl]).modal-card .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}:host(.modal-card){--backdrop-opacity:0;--width:100%;-ms-flex-align:end;align-items:flex-end}:host(.modal-card) .modal-shadow{display:none}:host(.modal-card) ion-backdrop{pointer-events:none}}@media screen and (min-width: 768px){:host(.modal-card){--width:calc(100% - 120px);--height:calc(100% - (120px + var(--ion-safe-area-top) + var(--ion-safe-area-bottom)));--max-width:720px;--max-height:1000px;--backdrop-opacity:0;--box-shadow:0px 0px 30px 10px rgba(0, 0, 0, 0.1);-webkit-transition:all 0.5s ease-in-out;transition:all 0.5s ease-in-out}:host(.modal-card) .modal-wrapper{-webkit-box-shadow:none;box-shadow:none}:host(.modal-card) .modal-shadow{-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow)}}:host(.modal-sheet) .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl]):host(.modal-sheet) .modal-wrapper,:host-context([dir=rtl]).modal-sheet .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}\";\nvar modalMdCss = \":host{--width:100%;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--overflow:hidden;--border-radius:0;--border-width:0;--border-style:none;--border-color:transparent;--background:var(--ion-background-color, #fff);--box-shadow:none;--backdrop-opacity:0;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;contain:strict;pointer-events:none}:host(.modal-interactive) .modal-wrapper,:host(.modal-interactive) ion-backdrop{pointer-events:auto}:host(.overlay-hidden){display:none}.modal-wrapper,.modal-shadow{border-radius:var(--border-radius);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:var(--overflow);z-index:10}.modal-shadow{position:absolute;background:transparent}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--width:600px;--height:500px;--ion-safe-area-top:0px;--ion-safe-area-bottom:0px;--ion-safe-area-right:0px;--ion-safe-area-left:0px}}@media only screen and (min-width: 768px) and (min-height: 768px){:host{--width:600px;--height:600px}}.modal-handle{left:0px;right:0px;top:5px;border-radius:8px;margin-left:auto;margin-right:auto;position:absolute;width:36px;height:5px;-webkit-transform:translateZ(0);transform:translateZ(0);background:var(--ion-color-step-350, #c0c0be);z-index:11}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.modal-handle{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}:host(.modal-sheet){--height:calc(100% - (var(--ion-safe-area-top) + 10px))}:host(.modal-sheet) .modal-wrapper,:host(.modal-sheet) .modal-shadow{position:absolute;bottom:0}:host{--backdrop-opacity:var(--ion-backdrop-opacity, 0.32)}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--border-radius:2px;--box-shadow:0 28px 48px rgba(0, 0, 0, 0.4)}}.modal-wrapper{-webkit-transform:translate3d(0,  40px,  0);transform:translate3d(0,  40px,  0);opacity:0.01}\";\n\nvar Modal = /*#__PURE__*/function () {\n  function Modal(hostRef) {\n    var _this12 = this;\n\n    _classCallCheck(this, Modal);\n\n    registerInstance(this, hostRef);\n    this.didPresent = createEvent(this, \"ionModalDidPresent\", 7);\n    this.willPresent = createEvent(this, \"ionModalWillPresent\", 7);\n    this.willDismiss = createEvent(this, \"ionModalWillDismiss\", 7);\n    this.didDismiss = createEvent(this, \"ionModalDidDismiss\", 7);\n    this.didPresentShorthand = createEvent(this, \"didPresent\", 7);\n    this.willPresentShorthand = createEvent(this, \"willPresent\", 7);\n    this.willDismissShorthand = createEvent(this, \"willDismiss\", 7);\n    this.didDismissShorthand = createEvent(this, \"didDismiss\", 7);\n    this.modalIndex = modalIds++;\n    this.coreDelegate = CoreDelegate();\n    this.isSheetModal = false;\n    this.inline = false; // Whether or not modal is being dismissed via gesture\n\n    this.gestureAnimationDismissing = false;\n    this.presented = false;\n    /** @internal */\n\n    this.hasController = false;\n    /**\n     * If `true`, the keyboard will be automatically dismissed when the overlay is presented.\n     */\n\n    this.keyboardClose = true;\n    /**\n     * A decimal value between 0 and 1 that indicates the\n     * point after which the backdrop will begin to fade in\n     * when using a sheet modal. Prior to this point, the\n     * backdrop will be hidden and the content underneath\n     * the sheet can be interacted with. This value is exclusive\n     * meaning the backdrop will become active after the value\n     * specified.\n     */\n\n    this.backdropBreakpoint = 0;\n    /**\n     * If `true`, the modal will be dismissed when the backdrop is clicked.\n     */\n\n    this.backdropDismiss = true;\n    /**\n     * If `true`, a backdrop will be displayed behind the modal.\n     */\n\n    this.showBackdrop = true;\n    /**\n     * If `true`, the modal will animate.\n     */\n\n    this.animated = true;\n    /**\n     * If `true`, the modal can be swiped to dismiss. Only applies in iOS mode.\n     */\n\n    this.swipeToClose = false;\n    /**\n     * If `true`, the modal will open. If `false`, the modal will close.\n     * Use this if you need finer grained control over presentation, otherwise\n     * just use the modalController or the `trigger` property.\n     * Note: `isOpen` will not automatically be set back to `false` when\n     * the modal dismisses. You will need to do that in your code.\n     */\n\n    this.isOpen = false;\n\n    this.configureTriggerInteraction = function () {\n      var trigger = _this12.trigger,\n          el = _this12.el,\n          destroyTriggerInteraction = _this12.destroyTriggerInteraction;\n\n      if (destroyTriggerInteraction) {\n        destroyTriggerInteraction();\n      }\n\n      var triggerEl = trigger !== undefined ? document.getElementById(trigger) : null;\n\n      if (!triggerEl) {\n        return;\n      }\n\n      var configureTriggerInteraction = function configureTriggerInteraction(trigEl, modalEl) {\n        var openModal = function openModal() {\n          modalEl.present();\n        };\n\n        trigEl.addEventListener('click', openModal);\n        return function () {\n          trigEl.removeEventListener('click', openModal);\n        };\n      };\n\n      _this12.destroyTriggerInteraction = configureTriggerInteraction(triggerEl, el);\n    };\n\n    this.onBackdropTap = function () {\n      _this12.dismiss(undefined, BACKDROP);\n    };\n\n    this.onDismiss = function (ev) {\n      ev.stopPropagation();\n      ev.preventDefault();\n\n      _this12.dismiss();\n    };\n\n    this.onLifecycle = function (modalEvent) {\n      var el = _this12.usersElement;\n      var name = LIFECYCLE_MAP$1[modalEvent.type];\n\n      if (el && name) {\n        var ev = new CustomEvent(name, {\n          bubbles: false,\n          cancelable: false,\n          detail: modalEvent.detail\n        });\n        el.dispatchEvent(ev);\n      }\n    };\n  }\n\n  _createClass(Modal, [{\n    key: \"onIsOpenChange\",\n    value: function onIsOpenChange(newValue, oldValue) {\n      if (newValue === true && oldValue === false) {\n        this.present();\n      } else if (newValue === false && oldValue === true) {\n        this.dismiss();\n      }\n    }\n  }, {\n    key: \"onTriggerChange\",\n    value: function onTriggerChange() {\n      this.configureTriggerInteraction();\n    }\n  }, {\n    key: \"swipeToCloseChanged\",\n    value: function swipeToCloseChanged(enable) {\n      if (this.gesture) {\n        this.gesture.enable(enable);\n      } else if (enable) {\n        this.initSwipeToClose();\n      }\n    }\n  }, {\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      prepareOverlay(this.el);\n    }\n  }, {\n    key: \"componentWillLoad\",\n    value: function componentWillLoad() {\n      var breakpoints = this.breakpoints,\n          initialBreakpoint = this.initialBreakpoint;\n      /**\n       * If user has custom ID set then we should\n       * not assign the default incrementing ID.\n       */\n\n      this.modalId = this.el.hasAttribute('id') ? this.el.getAttribute('id') : \"ion-modal-\".concat(this.modalIndex);\n      this.isSheetModal = breakpoints !== undefined && initialBreakpoint !== undefined;\n\n      if (breakpoints !== undefined && initialBreakpoint !== undefined && !breakpoints.includes(initialBreakpoint)) {\n        console.warn('[Ionic Warning]: Your breakpoints array must include the initialBreakpoint value.');\n      }\n    }\n  }, {\n    key: \"componentDidLoad\",\n    value: function componentDidLoad() {\n      var _this13 = this;\n\n      /**\n       * If modal was rendered with isOpen=\"true\"\n       * then we should open modal immediately.\n       */\n      if (this.isOpen === true) {\n        raf(function () {\n          return _this13.present();\n        });\n      }\n\n      this.configureTriggerInteraction();\n    }\n    /**\n     * Determines whether or not an overlay\n     * is being used inline or via a controller/JS\n     * and returns the correct delegate.\n     * By default, subsequent calls to getDelegate\n     * will use a cached version of the delegate.\n     * This is useful for calling dismiss after\n     * present so that the correct delegate is given.\n     */\n\n  }, {\n    key: \"getDelegate\",\n    value: function getDelegate() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.workingDelegate && !force) {\n        return {\n          delegate: this.workingDelegate,\n          inline: this.inline\n        };\n      }\n      /**\n       * If using overlay inline\n       * we potentially need to use the coreDelegate\n       * so that this works in vanilla JS apps.\n       * If a developer has presented this component\n       * via a controller, then we can assume\n       * the component is already in the\n       * correct place.\n       */\n\n\n      var parentEl = this.el.parentNode;\n      var inline = this.inline = parentEl !== null && !this.hasController;\n      var delegate = this.workingDelegate = inline ? this.delegate || this.coreDelegate : this.delegate;\n      return {\n        inline: inline,\n        delegate: delegate\n      };\n    }\n    /**\n     * Present the modal overlay after it has been created.\n     */\n\n  }, {\n    key: \"present\",\n    value: function () {\n      var _present3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this14 = this;\n\n        var data, _this$getDelegate, inline, delegate;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!this.presented) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 2:\n                if (!(this.currentTransition !== undefined)) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                _context4.next = 5;\n                return this.currentTransition;\n\n              case 5:\n                data = Object.assign(Object.assign({}, this.componentProps), {\n                  modal: this.el\n                });\n                _this$getDelegate = this.getDelegate(true), inline = _this$getDelegate.inline, delegate = _this$getDelegate.delegate;\n                _context4.next = 9;\n                return attachComponent(delegate, this.el, this.component, ['ion-page'], data, inline);\n\n              case 9:\n                this.usersElement = _context4.sent;\n                _context4.next = 12;\n                return deepReady(this.usersElement);\n\n              case 12:\n                writeTask(function () {\n                  return _this14.el.classList.add('show-modal');\n                });\n                this.currentTransition = _present(this, 'modalEnter', iosEnterAnimation$3, mdEnterAnimation$2, {\n                  presentingEl: this.presentingElement,\n                  currentBreakpoint: this.initialBreakpoint,\n                  backdropBreakpoint: this.backdropBreakpoint\n                });\n                _context4.next = 16;\n                return this.currentTransition;\n\n              case 16:\n                if (this.isSheetModal) {\n                  this.initSheetGesture();\n                } else if (this.swipeToClose) {\n                  this.initSwipeToClose();\n                }\n                /* tslint:disable-next-line */\n\n\n                if (typeof window !== 'undefined') {\n                  this.keyboardOpenCallback = function () {\n                    if (_this14.gesture) {\n                      /**\n                       * When the native keyboard is opened and the webview\n                       * is resized, the gesture implementation will become unresponsive\n                       * and enter a free-scroll mode.\n                       *\n                       * When the keyboard is opened, we disable the gesture for\n                       * a single frame and re-enable once the contents have repositioned\n                       * from the keyboard placement.\n                       */\n                      _this14.gesture.enable(false);\n\n                      raf(function () {\n                        if (_this14.gesture) {\n                          _this14.gesture.enable(true);\n                        }\n                      });\n                    }\n                  };\n\n                  window.addEventListener(KEYBOARD_DID_OPEN, this.keyboardOpenCallback);\n                }\n\n                this.currentTransition = undefined;\n\n              case 19:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function present() {\n        return _present3.apply(this, arguments);\n      }\n\n      return present;\n    }()\n  }, {\n    key: \"initSwipeToClose\",\n    value: function initSwipeToClose() {\n      var _this15 = this;\n\n      if (getIonMode(this) !== 'ios') {\n        return;\n      } // All of the elements needed for the swipe gesture\n      // should be in the DOM and referenced by now, except\n      // for the presenting el\n\n\n      var animationBuilder = this.leaveAnimation || config.get('modalLeave', iosLeaveAnimation$3);\n      var ani = this.animation = animationBuilder(this.el, {\n        presentingEl: this.presentingElement\n      });\n      this.gesture = createSwipeToCloseGesture(this.el, ani, function () {\n        /**\n         * While the gesture animation is finishing\n         * it is possible for a user to tap the backdrop.\n         * This would result in the dismiss animation\n         * being played again. Typically this is avoided\n         * by setting `presented = false` on the overlay\n         * component; however, we cannot do that here as\n         * that would prevent the element from being\n         * removed from the DOM.\n         */\n        _this15.gestureAnimationDismissing = true;\n\n        _this15.animation.onFinish( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n          return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  _context5.next = 2;\n                  return _this15.dismiss(undefined, 'gesture');\n\n                case 2:\n                  _this15.gestureAnimationDismissing = false;\n\n                case 3:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }, _callee5);\n        })));\n      });\n      this.gesture.enable(true);\n    }\n  }, {\n    key: \"initSheetGesture\",\n    value: function initSheetGesture() {\n      var _this16 = this;\n\n      var _a;\n\n      var wrapperEl = this.wrapperEl,\n          initialBreakpoint = this.initialBreakpoint,\n          backdropBreakpoint = this.backdropBreakpoint;\n\n      if (!wrapperEl || initialBreakpoint === undefined) {\n        return;\n      }\n\n      var animationBuilder = this.enterAnimation || config.get('modalEnter', iosEnterAnimation$3);\n      var ani = this.animation = animationBuilder(this.el, {\n        presentingEl: this.presentingElement,\n        currentBreakpoint: initialBreakpoint,\n        backdropBreakpoint: backdropBreakpoint\n      });\n      ani.progressStart(true, 1);\n      var sortedBreakpoints = ((_a = this.breakpoints) === null || _a === void 0 ? void 0 : _a.sort(function (a, b) {\n        return a - b;\n      })) || [];\n      this.gesture = createSheetGesture(this.el, this.backdropEl, wrapperEl, initialBreakpoint, backdropBreakpoint, ani, sortedBreakpoints, function () {\n        /**\n         * While the gesture animation is finishing\n         * it is possible for a user to tap the backdrop.\n         * This would result in the dismiss animation\n         * being played again. Typically this is avoided\n         * by setting `presented = false` on the overlay\n         * component; however, we cannot do that here as\n         * that would prevent the element from being\n         * removed from the DOM.\n         */\n        _this16.gestureAnimationDismissing = true;\n\n        _this16.animation.onFinish( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n          return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  _context6.next = 2;\n                  return _this16.dismiss(undefined, 'gesture');\n\n                case 2:\n                  _this16.gestureAnimationDismissing = false;\n\n                case 3:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }, _callee6);\n        })));\n      }, function (breakpoint) {\n        _this16.currentBreakpoint = breakpoint;\n      });\n      this.gesture.enable(true);\n    }\n    /**\n     * Dismiss the modal overlay after it has been presented.\n     *\n     * @param data Any data to emit in the dismiss events.\n     * @param role The role of the element that is dismissing the modal. For example, 'cancel' or 'backdrop'.\n     */\n\n  }, {\n    key: \"dismiss\",\n    value: function () {\n      var _dismiss2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(data, role) {\n        var enteringAnimation, dismissed, _this$getDelegate2, delegate;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!(this.gestureAnimationDismissing && role !== 'gesture')) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", false);\n\n              case 2:\n                /* tslint:disable-next-line */\n                if (typeof window !== 'undefined' && this.keyboardOpenCallback) {\n                  window.removeEventListener(KEYBOARD_DID_OPEN, this.keyboardOpenCallback);\n                }\n                /**\n                 * When using an inline modal\n                 * and presenting a modal it is possible to\n                 * quickly dismiss the modal while it is\n                 * presenting. We need to await any current\n                 * transition to allow the present to finish\n                 * before dismissing again.\n                 */\n\n\n                if (!(this.currentTransition !== undefined)) {\n                  _context7.next = 6;\n                  break;\n                }\n\n                _context7.next = 6;\n                return this.currentTransition;\n\n              case 6:\n                enteringAnimation = activeAnimations.get(this) || [];\n                this.currentTransition = _dismiss(this, data, role, 'modalLeave', iosLeaveAnimation$3, mdLeaveAnimation$2, {\n                  presentingEl: this.presentingElement,\n                  currentBreakpoint: this.currentBreakpoint || this.initialBreakpoint,\n                  backdropBreakpoint: this.backdropBreakpoint\n                });\n                _context7.next = 10;\n                return this.currentTransition;\n\n              case 10:\n                dismissed = _context7.sent;\n\n                if (!dismissed) {\n                  _context7.next = 18;\n                  break;\n                }\n\n                _this$getDelegate2 = this.getDelegate(), delegate = _this$getDelegate2.delegate;\n                _context7.next = 15;\n                return detachComponent(delegate, this.usersElement);\n\n              case 15:\n                if (this.animation) {\n                  this.animation.destroy();\n                }\n\n                if (this.gesture) {\n                  this.gesture.destroy();\n                }\n\n                enteringAnimation.forEach(function (ani) {\n                  return ani.destroy();\n                });\n\n              case 18:\n                this.currentTransition = undefined;\n                this.animation = undefined;\n                return _context7.abrupt(\"return\", dismissed);\n\n              case 21:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function dismiss(_x3, _x4) {\n        return _dismiss2.apply(this, arguments);\n      }\n\n      return dismiss;\n    }()\n    /**\n     * Returns a promise that resolves when the modal did dismiss.\n     */\n\n  }, {\n    key: \"onDidDismiss\",\n    value: function onDidDismiss() {\n      return eventMethod(this.el, 'ionModalDidDismiss');\n    }\n    /**\n     * Returns a promise that resolves when the modal will dismiss.\n     */\n\n  }, {\n    key: \"onWillDismiss\",\n    value: function onWillDismiss() {\n      return eventMethod(this.el, 'ionModalWillDismiss');\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _Object$assign6,\n          _this17 = this;\n\n      var handle = this.handle,\n          isSheetModal = this.isSheetModal,\n          presentingElement = this.presentingElement,\n          htmlAttributes = this.htmlAttributes;\n      var showHandle = handle !== false && isSheetModal;\n      var mode = getIonMode(this);\n      var presented = this.presented,\n          modalId = this.modalId;\n      var isCardModal = presentingElement !== undefined && mode === 'ios';\n      return h(Host, Object.assign({\n        \"no-router\": true,\n        \"aria-modal\": \"true\",\n        tabindex: \"-1\"\n      }, htmlAttributes, {\n        style: {\n          zIndex: \"\".concat(20000 + this.overlayIndex)\n        },\n        class: Object.assign((_Object$assign6 = {}, _defineProperty(_Object$assign6, mode, true), _defineProperty(_Object$assign6, 'modal-default', !isCardModal && !isSheetModal), _defineProperty(_Object$assign6, \"modal-card\", isCardModal), _defineProperty(_Object$assign6, \"modal-sheet\", isSheetModal), _defineProperty(_Object$assign6, 'overlay-hidden', true), _defineProperty(_Object$assign6, 'modal-interactive', presented), _Object$assign6), getClassMap(this.cssClass)),\n        id: modalId,\n        onIonBackdropTap: this.onBackdropTap,\n        onIonDismiss: this.onDismiss,\n        onIonModalDidPresent: this.onLifecycle,\n        onIonModalWillPresent: this.onLifecycle,\n        onIonModalWillDismiss: this.onLifecycle,\n        onIonModalDidDismiss: this.onLifecycle\n      }), h(\"ion-backdrop\", {\n        ref: function ref(el) {\n          return _this17.backdropEl = el;\n        },\n        visible: this.showBackdrop,\n        tappable: this.backdropDismiss,\n        part: \"backdrop\"\n      }), mode === 'ios' && h(\"div\", {\n        class: \"modal-shadow\"\n      }), h(\"div\", {\n        role: \"dialog\",\n        class: \"modal-wrapper ion-overlay-wrapper\",\n        part: \"content\",\n        ref: function ref(el) {\n          return _this17.wrapperEl = el;\n        }\n      }, showHandle && h(\"div\", {\n        class: \"modal-handle\",\n        part: \"handle\"\n      }), h(\"slot\", null)));\n    }\n  }, {\n    key: \"el\",\n    get: function get() {\n      return getElement(this);\n    }\n  }], [{\n    key: \"watchers\",\n    get: function get() {\n      return {\n        \"isOpen\": [\"onIsOpenChange\"],\n        \"trigger\": [\"onTriggerChange\"],\n        \"swipeToClose\": [\"swipeToCloseChanged\"]\n      };\n    }\n  }]);\n\n  return Modal;\n}();\n\nvar LIFECYCLE_MAP$1 = {\n  'ionModalDidPresent': 'ionViewDidEnter',\n  'ionModalWillPresent': 'ionViewWillEnter',\n  'ionModalWillDismiss': 'ionViewWillLeave',\n  'ionModalDidDismiss': 'ionViewDidLeave'\n};\nvar modalIds = 0;\nModal.style = {\n  ios: modalIosCss,\n  md: modalMdCss\n};\nvar pickerColumnIosCss = \".picker-col{display:-ms-flexbox;display:flex;position:relative;-ms-flex:1;flex:1;-ms-flex-pack:center;justify-content:center;height:100%;-webkit-box-sizing:content-box;box-sizing:content-box;contain:content}.picker-opts{position:relative;-ms-flex:1;flex:1;max-width:100%}.picker-opt{left:0;top:0;display:block;position:absolute;width:100%;border:0;text-align:center;text-overflow:ellipsis;white-space:nowrap;contain:strict;overflow:hidden;will-change:transform}[dir=rtl] .picker-opt,:host-context([dir=rtl]) .picker-opt{left:unset;right:unset;right:0}.picker-opt.picker-opt-disabled{pointer-events:none}.picker-opt-disabled{opacity:0}.picker-opts-left{-ms-flex-pack:start;justify-content:flex-start}.picker-opts-right{-ms-flex-pack:end;justify-content:flex-end}.picker-opt:active,.picker-opt:focus{outline:none}.picker-prefix{position:relative;-ms-flex:1;flex:1;text-align:end;white-space:nowrap}.picker-suffix{position:relative;-ms-flex:1;flex:1;text-align:start;white-space:nowrap}.picker-col{padding-left:4px;padding-right:4px;padding-top:0;padding-bottom:0;-webkit-transform-style:preserve-3d;transform-style:preserve-3d}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.picker-col{padding-left:unset;padding-right:unset;-webkit-padding-start:4px;padding-inline-start:4px;-webkit-padding-end:4px;padding-inline-end:4px}}.picker-prefix,.picker-suffix,.picker-opts{top:77px;-webkit-transform-style:preserve-3d;transform-style:preserve-3d;color:inherit;font-size:20px;line-height:42px;pointer-events:none}.picker-opt{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-transform-origin:center center;transform-origin:center center;height:46px;-webkit-transform-style:preserve-3d;transform-style:preserve-3d;-webkit-transition-timing-function:ease-out;transition-timing-function:ease-out;background:transparent;color:inherit;font-size:20px;line-height:42px;-webkit-backface-visibility:hidden;backface-visibility:hidden;pointer-events:auto}[dir=rtl] .picker-opt,:host-context([dir=rtl]) .picker-opt{-webkit-transform-origin:calc(100% - center) center;transform-origin:calc(100% - center) center}\";\nvar pickerColumnMdCss = \".picker-col{display:-ms-flexbox;display:flex;position:relative;-ms-flex:1;flex:1;-ms-flex-pack:center;justify-content:center;height:100%;-webkit-box-sizing:content-box;box-sizing:content-box;contain:content}.picker-opts{position:relative;-ms-flex:1;flex:1;max-width:100%}.picker-opt{left:0;top:0;display:block;position:absolute;width:100%;border:0;text-align:center;text-overflow:ellipsis;white-space:nowrap;contain:strict;overflow:hidden;will-change:transform}[dir=rtl] .picker-opt,:host-context([dir=rtl]) .picker-opt{left:unset;right:unset;right:0}.picker-opt.picker-opt-disabled{pointer-events:none}.picker-opt-disabled{opacity:0}.picker-opts-left{-ms-flex-pack:start;justify-content:flex-start}.picker-opts-right{-ms-flex-pack:end;justify-content:flex-end}.picker-opt:active,.picker-opt:focus{outline:none}.picker-prefix{position:relative;-ms-flex:1;flex:1;text-align:end;white-space:nowrap}.picker-suffix{position:relative;-ms-flex:1;flex:1;text-align:start;white-space:nowrap}.picker-col{padding-left:8px;padding-right:8px;padding-top:0;padding-bottom:0;-webkit-transform-style:preserve-3d;transform-style:preserve-3d}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.picker-col{padding-left:unset;padding-right:unset;-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px}}.picker-prefix,.picker-suffix,.picker-opts{top:77px;-webkit-transform-style:preserve-3d;transform-style:preserve-3d;color:inherit;font-size:22px;line-height:42px;pointer-events:none}.picker-opt{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;height:43px;-webkit-transition-timing-function:ease-out;transition-timing-function:ease-out;background:transparent;color:inherit;font-size:22px;line-height:42px;-webkit-backface-visibility:hidden;backface-visibility:hidden;pointer-events:auto}.picker-prefix,.picker-suffix,.picker-opt.picker-opt-selected{color:var(--ion-color-primary, #3880ff)}\";\n\nvar PickerColumnCmp = /*#__PURE__*/function () {\n  function PickerColumnCmp(hostRef) {\n    _classCallCheck(this, PickerColumnCmp);\n\n    registerInstance(this, hostRef);\n    this.ionPickerColChange = createEvent(this, \"ionPickerColChange\", 7);\n    this.optHeight = 0;\n    this.rotateFactor = 0;\n    this.scaleFactor = 1;\n    this.velocity = 0;\n    this.y = 0;\n    this.noAnimate = true;\n  }\n\n  _createClass(PickerColumnCmp, [{\n    key: \"colChanged\",\n    value: function colChanged() {\n      this.refresh();\n    }\n  }, {\n    key: \"connectedCallback\",\n    value: function () {\n      var _connectedCallback = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var _this18 = this;\n\n        var pickerRotateFactor, pickerScaleFactor, mode;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                pickerRotateFactor = 0;\n                pickerScaleFactor = 0.81;\n                mode = getIonMode(this);\n\n                if (mode === 'ios') {\n                  pickerRotateFactor = -0.46;\n                  pickerScaleFactor = 1;\n                }\n\n                this.rotateFactor = pickerRotateFactor;\n                this.scaleFactor = pickerScaleFactor;\n                _context8.next = 8;\n                return import('./index-41bf41f2.js');\n\n              case 8:\n                this.gesture = _context8.sent.createGesture({\n                  el: this.el,\n                  gestureName: 'picker-swipe',\n                  gesturePriority: 100,\n                  threshold: 0,\n                  passive: false,\n                  onStart: function onStart(ev) {\n                    return _this18.onStart(ev);\n                  },\n                  onMove: function onMove(ev) {\n                    return _this18.onMove(ev);\n                  },\n                  onEnd: function onEnd(ev) {\n                    return _this18.onEnd(ev);\n                  }\n                });\n                this.gesture.enable();\n                this.tmrId = setTimeout(function () {\n                  _this18.noAnimate = false;\n\n                  _this18.refresh(true);\n                }, 250);\n\n              case 11:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function connectedCallback() {\n        return _connectedCallback.apply(this, arguments);\n      }\n\n      return connectedCallback;\n    }()\n  }, {\n    key: \"componentDidLoad\",\n    value: function componentDidLoad() {\n      var colEl = this.optsEl;\n\n      if (colEl) {\n        // DOM READ\n        // We perfom a DOM read over a rendered item, this needs to happen after the first render\n        this.optHeight = colEl.firstElementChild ? colEl.firstElementChild.clientHeight : 0;\n      }\n\n      this.refresh();\n    }\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      cancelAnimationFrame(this.rafId);\n      clearTimeout(this.tmrId);\n\n      if (this.gesture) {\n        this.gesture.destroy();\n        this.gesture = undefined;\n      }\n    }\n  }, {\n    key: \"emitColChange\",\n    value: function emitColChange() {\n      this.ionPickerColChange.emit(this.col);\n    }\n  }, {\n    key: \"setSelected\",\n    value: function setSelected(selectedIndex, duration) {\n      // if there is a selected index, then figure out it's y position\n      // if there isn't a selected index, then just use the top y position\n      var y = selectedIndex > -1 ? -(selectedIndex * this.optHeight) : 0;\n      this.velocity = 0; // set what y position we're at\n\n      cancelAnimationFrame(this.rafId);\n      this.update(y, duration, true);\n      this.emitColChange();\n    }\n  }, {\n    key: \"update\",\n    value: function update(y, duration, saveY) {\n      if (!this.optsEl) {\n        return;\n      } // ensure we've got a good round number :)\n\n\n      var translateY = 0;\n      var translateZ = 0;\n      var col = this.col,\n          rotateFactor = this.rotateFactor;\n      var selectedIndex = col.selectedIndex = this.indexForY(-y);\n      var durationStr = duration === 0 ? '' : duration + 'ms';\n      var scaleStr = \"scale(\".concat(this.scaleFactor, \")\");\n      var children = this.optsEl.children;\n\n      for (var i = 0; i < children.length; i++) {\n        var button = children[i];\n        var opt = col.options[i];\n        var optOffset = i * this.optHeight + y;\n        var transform = '';\n\n        if (rotateFactor !== 0) {\n          var rotateX = optOffset * rotateFactor;\n\n          if (Math.abs(rotateX) <= 90) {\n            translateY = 0;\n            translateZ = 90;\n            transform = \"rotateX(\".concat(rotateX, \"deg) \");\n          } else {\n            translateY = -9999;\n          }\n        } else {\n          translateZ = 0;\n          translateY = optOffset;\n        }\n\n        var selected = selectedIndex === i;\n        transform += \"translate3d(0px,\".concat(translateY, \"px,\").concat(translateZ, \"px) \");\n\n        if (this.scaleFactor !== 1 && !selected) {\n          transform += scaleStr;\n        } // Update transition duration\n\n\n        if (this.noAnimate) {\n          opt.duration = 0;\n          button.style.transitionDuration = '';\n        } else if (duration !== opt.duration) {\n          opt.duration = duration;\n          button.style.transitionDuration = durationStr;\n        } // Update transform\n\n\n        if (transform !== opt.transform) {\n          opt.transform = transform;\n          button.style.transform = transform;\n        } // Update selected item\n\n\n        if (selected !== opt.selected) {\n          opt.selected = selected;\n\n          if (selected) {\n            button.classList.add(PICKER_OPT_SELECTED);\n          } else {\n            button.classList.remove(PICKER_OPT_SELECTED);\n          }\n        }\n      }\n\n      this.col.prevSelected = selectedIndex;\n\n      if (saveY) {\n        this.y = y;\n      }\n\n      if (this.lastIndex !== selectedIndex) {\n        // have not set a last index yet\n        hapticSelectionChanged();\n        this.lastIndex = selectedIndex;\n      }\n    }\n  }, {\n    key: \"decelerate\",\n    value: function decelerate() {\n      var _this19 = this;\n\n      if (this.velocity !== 0) {\n        // still decelerating\n        this.velocity *= DECELERATION_FRICTION; // do not let it go slower than a velocity of 1\n\n        this.velocity = this.velocity > 0 ? Math.max(this.velocity, 1) : Math.min(this.velocity, -1);\n        var y = this.y + this.velocity;\n\n        if (y > this.minY) {\n          // whoops, it's trying to scroll up farther than the options we have!\n          y = this.minY;\n          this.velocity = 0;\n        } else if (y < this.maxY) {\n          // gahh, it's trying to scroll down farther than we can!\n          y = this.maxY;\n          this.velocity = 0;\n        }\n\n        this.update(y, 0, true);\n        var notLockedIn = Math.round(y) % this.optHeight !== 0 || Math.abs(this.velocity) > 1;\n\n        if (notLockedIn) {\n          // isn't locked in yet, keep decelerating until it is\n          this.rafId = requestAnimationFrame(function () {\n            return _this19.decelerate();\n          });\n        } else {\n          this.velocity = 0;\n          this.emitColChange();\n          hapticSelectionEnd();\n        }\n      } else if (this.y % this.optHeight !== 0) {\n        // needs to still get locked into a position so options line up\n        var currentPos = Math.abs(this.y % this.optHeight); // create a velocity in the direction it needs to scroll\n\n        this.velocity = currentPos > this.optHeight / 2 ? 1 : -1;\n        this.decelerate();\n      }\n    }\n  }, {\n    key: \"indexForY\",\n    value: function indexForY(y) {\n      return Math.min(Math.max(Math.abs(Math.round(y / this.optHeight)), 0), this.col.options.length - 1);\n    } // TODO should this check disabled?\n\n  }, {\n    key: \"onStart\",\n    value: function onStart(detail) {\n      // We have to prevent default in order to block scrolling under the picker\n      // but we DO NOT have to stop propagation, since we still want\n      // some \"click\" events to capture\n      if (detail.event.cancelable) {\n        detail.event.preventDefault();\n      }\n\n      detail.event.stopPropagation();\n      hapticSelectionStart(); // reset everything\n\n      cancelAnimationFrame(this.rafId);\n      var options = this.col.options;\n      var minY = options.length - 1;\n      var maxY = 0;\n\n      for (var i = 0; i < options.length; i++) {\n        if (!options[i].disabled) {\n          minY = Math.min(minY, i);\n          maxY = Math.max(maxY, i);\n        }\n      }\n\n      this.minY = -(minY * this.optHeight);\n      this.maxY = -(maxY * this.optHeight);\n    }\n  }, {\n    key: \"onMove\",\n    value: function onMove(detail) {\n      if (detail.event.cancelable) {\n        detail.event.preventDefault();\n      }\n\n      detail.event.stopPropagation(); // update the scroll position relative to pointer start position\n\n      var y = this.y + detail.deltaY;\n\n      if (y > this.minY) {\n        // scrolling up higher than scroll area\n        y = Math.pow(y, 0.8);\n        this.bounceFrom = y;\n      } else if (y < this.maxY) {\n        // scrolling down below scroll area\n        y += Math.pow(this.maxY - y, 0.9);\n        this.bounceFrom = y;\n      } else {\n        this.bounceFrom = 0;\n      }\n\n      this.update(y, 0, false);\n    }\n  }, {\n    key: \"onEnd\",\n    value: function onEnd(detail) {\n      if (this.bounceFrom > 0) {\n        // bounce back up\n        this.update(this.minY, 100, true);\n        this.emitColChange();\n        return;\n      } else if (this.bounceFrom < 0) {\n        // bounce back down\n        this.update(this.maxY, 100, true);\n        this.emitColChange();\n        return;\n      }\n\n      this.velocity = clamp(-MAX_PICKER_SPEED, detail.velocityY * 23, MAX_PICKER_SPEED);\n\n      if (this.velocity === 0 && detail.deltaY === 0) {\n        var opt = detail.event.target.closest('.picker-opt');\n\n        if (opt && opt.hasAttribute('opt-index')) {\n          this.setSelected(parseInt(opt.getAttribute('opt-index'), 10), TRANSITION_DURATION);\n        }\n      } else {\n        this.y += detail.deltaY;\n\n        if (Math.abs(detail.velocityY) < 0.05) {\n          var isScrollingUp = detail.deltaY > 0;\n          var optHeightFraction = Math.abs(this.y) % this.optHeight / this.optHeight;\n\n          if (isScrollingUp && optHeightFraction > 0.5) {\n            this.velocity = Math.abs(this.velocity) * -1;\n          } else if (!isScrollingUp && optHeightFraction <= 0.5) {\n            this.velocity = Math.abs(this.velocity);\n          }\n        }\n\n        this.decelerate();\n      }\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh(forceRefresh) {\n      var min = this.col.options.length - 1;\n      var max = 0;\n      var options = this.col.options;\n\n      for (var i = 0; i < options.length; i++) {\n        if (!options[i].disabled) {\n          min = Math.min(min, i);\n          max = Math.max(max, i);\n        }\n      }\n      /**\n       * Only update selected value if column has a\n       * velocity of 0. If it does not, then the\n       * column is animating might land on\n       * a value different than the value at\n       * selectedIndex\n       */\n\n\n      if (this.velocity !== 0) {\n        return;\n      }\n\n      var selectedIndex = clamp(min, this.col.selectedIndex || 0, max);\n\n      if (this.col.prevSelected !== selectedIndex || forceRefresh) {\n        var y = selectedIndex * this.optHeight * -1;\n        this.velocity = 0;\n        this.update(y, TRANSITION_DURATION, true);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _class,\n          _this20 = this;\n\n      var col = this.col;\n      var Button = 'button';\n      var mode = getIonMode(this);\n      return h(Host, {\n        class: (_class = {}, _defineProperty(_class, mode, true), _defineProperty(_class, 'picker-col', true), _defineProperty(_class, 'picker-opts-left', this.col.align === 'left'), _defineProperty(_class, 'picker-opts-right', this.col.align === 'right'), _class),\n        style: {\n          'max-width': this.col.columnWidth\n        }\n      }, col.prefix && h(\"div\", {\n        class: \"picker-prefix\",\n        style: {\n          width: col.prefixWidth\n        }\n      }, col.prefix), h(\"div\", {\n        class: \"picker-opts\",\n        style: {\n          maxWidth: col.optionsWidth\n        },\n        ref: function ref(el) {\n          return _this20.optsEl = el;\n        }\n      }, col.options.map(function (o, index) {\n        return h(Button, {\n          type: \"button\",\n          class: {\n            'picker-opt': true,\n            'picker-opt-disabled': !!o.disabled\n          },\n          \"opt-index\": index\n        }, o.text);\n      })), col.suffix && h(\"div\", {\n        class: \"picker-suffix\",\n        style: {\n          width: col.suffixWidth\n        }\n      }, col.suffix));\n    }\n  }, {\n    key: \"el\",\n    get: function get() {\n      return getElement(this);\n    }\n  }], [{\n    key: \"watchers\",\n    get: function get() {\n      return {\n        \"col\": [\"colChanged\"]\n      };\n    }\n  }]);\n\n  return PickerColumnCmp;\n}();\n\nvar PICKER_OPT_SELECTED = 'picker-opt-selected';\nvar DECELERATION_FRICTION = 0.97;\nvar MAX_PICKER_SPEED = 90;\nvar TRANSITION_DURATION = 150;\nPickerColumnCmp.style = {\n  ios: pickerColumnIosCss,\n  md: pickerColumnMdCss\n};\n/**\n * iOS Picker Enter Animation\n */\n\nvar iosEnterAnimation$2 = function iosEnterAnimation$2(baseEl) {\n  var baseAnimation = createAnimation();\n  var backdropAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 0.01, 'var(--backdrop-opacity)').beforeStyles({\n    'pointer-events': 'none'\n  }).afterClearStyles(['pointer-events']);\n  wrapperAnimation.addElement(baseEl.querySelector('.picker-wrapper')).fromTo('transform', 'translateY(100%)', 'translateY(0%)');\n  return baseAnimation.addElement(baseEl).easing('cubic-bezier(.36,.66,.04,1)').duration(400).addAnimation([backdropAnimation, wrapperAnimation]);\n};\n/**\n * iOS Picker Leave Animation\n */\n\n\nvar iosLeaveAnimation$2 = function iosLeaveAnimation$2(baseEl) {\n  var baseAnimation = createAnimation();\n  var backdropAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0.01);\n  wrapperAnimation.addElement(baseEl.querySelector('.picker-wrapper')).fromTo('transform', 'translateY(0%)', 'translateY(100%)');\n  return baseAnimation.addElement(baseEl).easing('cubic-bezier(.36,.66,.04,1)').duration(400).addAnimation([backdropAnimation, wrapperAnimation]);\n};\n\nvar pickerIosCss = \".sc-ion-picker-ios-h{--border-radius:0;--border-style:solid;--min-width:auto;--width:100%;--max-width:500px;--min-height:auto;--max-height:auto;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;top:0;display:block;position:absolute;width:100%;height:100%;outline:none;font-family:var(--ion-font-family, inherit);contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1001}[dir=rtl].sc-ion-picker-ios-h,[dir=rtl] .sc-ion-picker-ios-h{left:unset;right:unset;right:0}.overlay-hidden.sc-ion-picker-ios-h{display:none}.picker-wrapper.sc-ion-picker-ios{border-radius:var(--border-radius);left:0;right:0;bottom:0;margin-left:auto;margin-right:auto;margin-top:auto;margin-bottom:auto;-webkit-transform:translate3d(0,  100%,  0);transform:translate3d(0,  100%,  0);display:-ms-flexbox;display:flex;position:absolute;-ms-flex-direction:column;flex-direction:column;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);contain:strict;overflow:hidden;z-index:10}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.picker-wrapper.sc-ion-picker-ios{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}.picker-toolbar.sc-ion-picker-ios{width:100%;background:transparent;contain:strict;z-index:1}.picker-button.sc-ion-picker-ios{border:0;font-family:inherit}.picker-button.sc-ion-picker-ios:active,.picker-button.sc-ion-picker-ios:focus{outline:none}.picker-columns.sc-ion-picker-ios{display:-ms-flexbox;display:flex;position:relative;-ms-flex-pack:center;justify-content:center;margin-bottom:var(--ion-safe-area-bottom, 0);contain:strict;direction:ltr;overflow:hidden}.picker-above-highlight.sc-ion-picker-ios,.picker-below-highlight.sc-ion-picker-ios{display:none;pointer-events:none}.sc-ion-picker-ios-h{--background:var(--ion-background-color, #fff);--border-width:1px 0 0;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, #c8c7cc)));--height:260px;--backdrop-opacity:var(--ion-backdrop-opacity, 0.26);color:var(--ion-item-color, var(--ion-text-color, #000))}.picker-toolbar.sc-ion-picker-ios{display:-ms-flexbox;display:flex;height:44px;border-bottom:0.55px solid var(--border-color)}.picker-toolbar-button.sc-ion-picker-ios{-ms-flex:1;flex:1;text-align:end}.picker-toolbar-button.sc-ion-picker-ios:last-child .picker-button.sc-ion-picker-ios{font-weight:600}.picker-toolbar-button.sc-ion-picker-ios:first-child{font-weight:normal;text-align:start}.picker-button.sc-ion-picker-ios,.picker-button.ion-activated.sc-ion-picker-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:1em;padding-right:1em;padding-top:0;padding-bottom:0;height:44px;background:transparent;color:var(--ion-color-primary, #3880ff);font-size:16px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.picker-button.sc-ion-picker-ios,.picker-button.ion-activated.sc-ion-picker-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:1em;padding-inline-start:1em;-webkit-padding-end:1em;padding-inline-end:1em}}.picker-columns.sc-ion-picker-ios{height:215px;-webkit-perspective:1000px;perspective:1000px}.picker-above-highlight.sc-ion-picker-ios{left:0;top:0;-webkit-transform:translate3d(0,  0,  90px);transform:translate3d(0,  0,  90px);display:block;position:absolute;width:100%;height:81px;border-bottom:1px solid var(--border-color);background:-webkit-gradient(linear, left top, left bottom, color-stop(20%, var(--background, var(--ion-background-color, #fff))), to(rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0.8)));background:linear-gradient(to bottom, var(--background, var(--ion-background-color, #fff)) 20%, rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0.8) 100%);z-index:10}[dir=rtl].sc-ion-picker-ios .picker-above-highlight.sc-ion-picker-ios,[dir=rtl].sc-ion-picker-ios-h .picker-above-highlight.sc-ion-picker-ios,[dir=rtl] .sc-ion-picker-ios-h .picker-above-highlight.sc-ion-picker-ios{left:unset;right:unset;right:0}.picker-below-highlight.sc-ion-picker-ios{left:0;top:115px;-webkit-transform:translate3d(0,  0,  90px);transform:translate3d(0,  0,  90px);display:block;position:absolute;width:100%;height:119px;border-top:1px solid var(--border-color);background:-webkit-gradient(linear, left bottom, left top, color-stop(30%, var(--background, var(--ion-background-color, #fff))), to(rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0.8)));background:linear-gradient(to top, var(--background, var(--ion-background-color, #fff)) 30%, rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0.8) 100%);z-index:11}[dir=rtl].sc-ion-picker-ios .picker-below-highlight.sc-ion-picker-ios,[dir=rtl].sc-ion-picker-ios-h .picker-below-highlight.sc-ion-picker-ios,[dir=rtl] .sc-ion-picker-ios-h .picker-below-highlight.sc-ion-picker-ios{left:unset;right:unset;right:0}\";\nvar pickerMdCss = \".sc-ion-picker-md-h{--border-radius:0;--border-style:solid;--min-width:auto;--width:100%;--max-width:500px;--min-height:auto;--max-height:auto;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;top:0;display:block;position:absolute;width:100%;height:100%;outline:none;font-family:var(--ion-font-family, inherit);contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1001}[dir=rtl].sc-ion-picker-md-h,[dir=rtl] .sc-ion-picker-md-h{left:unset;right:unset;right:0}.overlay-hidden.sc-ion-picker-md-h{display:none}.picker-wrapper.sc-ion-picker-md{border-radius:var(--border-radius);left:0;right:0;bottom:0;margin-left:auto;margin-right:auto;margin-top:auto;margin-bottom:auto;-webkit-transform:translate3d(0,  100%,  0);transform:translate3d(0,  100%,  0);display:-ms-flexbox;display:flex;position:absolute;-ms-flex-direction:column;flex-direction:column;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);contain:strict;overflow:hidden;z-index:10}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.picker-wrapper.sc-ion-picker-md{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}.picker-toolbar.sc-ion-picker-md{width:100%;background:transparent;contain:strict;z-index:1}.picker-button.sc-ion-picker-md{border:0;font-family:inherit}.picker-button.sc-ion-picker-md:active,.picker-button.sc-ion-picker-md:focus{outline:none}.picker-columns.sc-ion-picker-md{display:-ms-flexbox;display:flex;position:relative;-ms-flex-pack:center;justify-content:center;margin-bottom:var(--ion-safe-area-bottom, 0);contain:strict;direction:ltr;overflow:hidden}.picker-above-highlight.sc-ion-picker-md,.picker-below-highlight.sc-ion-picker-md{display:none;pointer-events:none}.sc-ion-picker-md-h{--background:var(--ion-background-color, #fff);--border-width:0.55px 0 0;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))));--height:260px;--backdrop-opacity:var(--ion-backdrop-opacity, 0.26);color:var(--ion-item-color, var(--ion-text-color, #000))}.picker-toolbar.sc-ion-picker-md{display:-ms-flexbox;display:flex;-ms-flex-pack:end;justify-content:flex-end;height:44px}.picker-button.sc-ion-picker-md,.picker-button.ion-activated.sc-ion-picker-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:1.1em;padding-right:1.1em;padding-top:0;padding-bottom:0;height:44px;background:transparent;color:var(--ion-color-primary, #3880ff);font-size:14px;font-weight:500;text-transform:uppercase;-webkit-box-shadow:none;box-shadow:none}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.picker-button.sc-ion-picker-md,.picker-button.ion-activated.sc-ion-picker-md{padding-left:unset;padding-right:unset;-webkit-padding-start:1.1em;padding-inline-start:1.1em;-webkit-padding-end:1.1em;padding-inline-end:1.1em}}.picker-columns.sc-ion-picker-md{height:216px;-webkit-perspective:1800px;perspective:1800px}.picker-above-highlight.sc-ion-picker-md{left:0;top:0;-webkit-transform:translate3d(0,  0,  90px);transform:translate3d(0,  0,  90px);position:absolute;width:100%;height:81px;border-bottom:1px solid var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))));background:-webkit-gradient(linear, left top, left bottom, color-stop(20%, var(--ion-background-color, #fff)), to(rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8)));background:linear-gradient(to bottom, var(--ion-background-color, #fff) 20%, rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8) 100%);z-index:10}[dir=rtl].sc-ion-picker-md .picker-above-highlight.sc-ion-picker-md,[dir=rtl].sc-ion-picker-md-h .picker-above-highlight.sc-ion-picker-md,[dir=rtl] .sc-ion-picker-md-h .picker-above-highlight.sc-ion-picker-md{left:unset;right:unset;right:0}.picker-below-highlight.sc-ion-picker-md{left:0;top:115px;-webkit-transform:translate3d(0,  0,  90px);transform:translate3d(0,  0,  90px);position:absolute;width:100%;height:119px;border-top:1px solid var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))));background:-webkit-gradient(linear, left bottom, left top, color-stop(30%, var(--ion-background-color, #fff)), to(rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8)));background:linear-gradient(to top, var(--ion-background-color, #fff) 30%, rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8) 100%);z-index:11}[dir=rtl].sc-ion-picker-md .picker-below-highlight.sc-ion-picker-md,[dir=rtl].sc-ion-picker-md-h .picker-below-highlight.sc-ion-picker-md,[dir=rtl] .sc-ion-picker-md-h .picker-below-highlight.sc-ion-picker-md{left:unset;right:unset;right:0}\";\n\nvar Picker = /*#__PURE__*/function () {\n  function Picker(hostRef) {\n    var _this21 = this;\n\n    _classCallCheck(this, Picker);\n\n    registerInstance(this, hostRef);\n    this.didPresent = createEvent(this, \"ionPickerDidPresent\", 7);\n    this.willPresent = createEvent(this, \"ionPickerWillPresent\", 7);\n    this.willDismiss = createEvent(this, \"ionPickerWillDismiss\", 7);\n    this.didDismiss = createEvent(this, \"ionPickerDidDismiss\", 7);\n    this.presented = false;\n    /**\n     * If `true`, the keyboard will be automatically dismissed when the overlay is presented.\n     */\n\n    this.keyboardClose = true;\n    /**\n     * Array of buttons to be displayed at the top of the picker.\n     */\n\n    this.buttons = [];\n    /**\n     * Array of columns to be displayed in the picker.\n     */\n\n    this.columns = [];\n    /**\n     * Number of milliseconds to wait before dismissing the picker.\n     */\n\n    this.duration = 0;\n    /**\n     * If `true`, a backdrop will be displayed behind the picker.\n     */\n\n    this.showBackdrop = true;\n    /**\n     * If `true`, the picker will be dismissed when the backdrop is clicked.\n     */\n\n    this.backdropDismiss = true;\n    /**\n     * If `true`, the picker will animate.\n     */\n\n    this.animated = true;\n\n    this.onBackdropTap = function () {\n      _this21.dismiss(undefined, BACKDROP);\n    };\n\n    this.dispatchCancelHandler = function (ev) {\n      var role = ev.detail.role;\n\n      if (isCancel(role)) {\n        var cancelButton = _this21.buttons.find(function (b) {\n          return b.role === 'cancel';\n        });\n\n        _this21.callButtonHandler(cancelButton);\n      }\n    };\n  }\n\n  _createClass(Picker, [{\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      prepareOverlay(this.el);\n    }\n    /**\n     * Present the picker overlay after it has been created.\n     */\n\n  }, {\n    key: \"present\",\n    value: function () {\n      var _present4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var _this22 = this;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return _present(this, 'pickerEnter', iosEnterAnimation$2, iosEnterAnimation$2, undefined);\n\n              case 2:\n                if (this.duration > 0) {\n                  this.durationTimeout = setTimeout(function () {\n                    return _this22.dismiss();\n                  }, this.duration);\n                }\n\n              case 3:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function present() {\n        return _present4.apply(this, arguments);\n      }\n\n      return present;\n    }()\n    /**\n     * Dismiss the picker overlay after it has been presented.\n     *\n     * @param data Any data to emit in the dismiss events.\n     * @param role The role of the element that is dismissing the picker.\n     * This can be useful in a button handler for determining which button was\n     * clicked to dismiss the picker.\n     * Some examples include: ``\"cancel\"`, `\"destructive\"`, \"selected\"`, and `\"backdrop\"`.\n     */\n\n  }, {\n    key: \"dismiss\",\n    value: function dismiss(data, role) {\n      if (this.durationTimeout) {\n        clearTimeout(this.durationTimeout);\n      }\n\n      return _dismiss(this, data, role, 'pickerLeave', iosLeaveAnimation$2, iosLeaveAnimation$2);\n    }\n    /**\n     * Returns a promise that resolves when the picker did dismiss.\n     */\n\n  }, {\n    key: \"onDidDismiss\",\n    value: function onDidDismiss() {\n      return eventMethod(this.el, 'ionPickerDidDismiss');\n    }\n    /**\n     * Returns a promise that resolves when the picker will dismiss.\n     */\n\n  }, {\n    key: \"onWillDismiss\",\n    value: function onWillDismiss() {\n      return eventMethod(this.el, 'ionPickerWillDismiss');\n    }\n    /**\n     * Get the column that matches the specified name.\n     *\n     * @param name The name of the column.\n     */\n\n  }, {\n    key: \"getColumn\",\n    value: function getColumn(name) {\n      return Promise.resolve(this.columns.find(function (column) {\n        return column.name === name;\n      }));\n    }\n  }, {\n    key: \"buttonClick\",\n    value: function () {\n      var _buttonClick2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(button) {\n        var role, shouldDismiss;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                role = button.role;\n\n                if (!isCancel(role)) {\n                  _context10.next = 3;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", this.dismiss(undefined, role));\n\n              case 3:\n                _context10.next = 5;\n                return this.callButtonHandler(button);\n\n              case 5:\n                shouldDismiss = _context10.sent;\n\n                if (!shouldDismiss) {\n                  _context10.next = 8;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", this.dismiss(this.getSelected(), button.role));\n\n              case 8:\n                return _context10.abrupt(\"return\", Promise.resolve());\n\n              case 9:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function buttonClick(_x5) {\n        return _buttonClick2.apply(this, arguments);\n      }\n\n      return buttonClick;\n    }()\n  }, {\n    key: \"callButtonHandler\",\n    value: function () {\n      var _callButtonHandler2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(button) {\n        var rtn;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (!button) {\n                  _context11.next = 6;\n                  break;\n                }\n\n                _context11.next = 3;\n                return safeCall(button.handler, this.getSelected());\n\n              case 3:\n                rtn = _context11.sent;\n\n                if (!(rtn === false)) {\n                  _context11.next = 6;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\", false);\n\n              case 6:\n                return _context11.abrupt(\"return\", true);\n\n              case 7:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function callButtonHandler(_x6) {\n        return _callButtonHandler2.apply(this, arguments);\n      }\n\n      return callButtonHandler;\n    }()\n  }, {\n    key: \"getSelected\",\n    value: function getSelected() {\n      var selected = {};\n      this.columns.forEach(function (col, index) {\n        var selectedColumn = col.selectedIndex !== undefined ? col.options[col.selectedIndex] : undefined;\n        selected[col.name] = {\n          text: selectedColumn ? selectedColumn.text : undefined,\n          value: selectedColumn ? selectedColumn.value : undefined,\n          columnIndex: index\n        };\n      });\n      return selected;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _Object$assign7,\n          _this23 = this;\n\n      var htmlAttributes = this.htmlAttributes;\n      var mode = getIonMode(this);\n      return h(Host, Object.assign({\n        \"aria-modal\": \"true\",\n        tabindex: \"-1\"\n      }, htmlAttributes, {\n        style: {\n          zIndex: \"\".concat(20000 + this.overlayIndex)\n        },\n        class: Object.assign((_Object$assign7 = {}, _defineProperty(_Object$assign7, mode, true), _defineProperty(_Object$assign7, \"picker-\".concat(mode), true), _defineProperty(_Object$assign7, 'overlay-hidden', true), _Object$assign7), getClassMap(this.cssClass)),\n        onIonBackdropTap: this.onBackdropTap,\n        onIonPickerWillDismiss: this.dispatchCancelHandler\n      }), h(\"ion-backdrop\", {\n        visible: this.showBackdrop,\n        tappable: this.backdropDismiss\n      }), h(\"div\", {\n        tabindex: \"0\"\n      }), h(\"div\", {\n        class: \"picker-wrapper ion-overlay-wrapper\",\n        role: \"dialog\"\n      }, h(\"div\", {\n        class: \"picker-toolbar\"\n      }, this.buttons.map(function (b) {\n        return h(\"div\", {\n          class: buttonWrapperClass(b)\n        }, h(\"button\", {\n          type: \"button\",\n          onClick: function onClick() {\n            return _this23.buttonClick(b);\n          },\n          class: buttonClass$1(b)\n        }, b.text));\n      })), h(\"div\", {\n        class: \"picker-columns\"\n      }, h(\"div\", {\n        class: \"picker-above-highlight\"\n      }), this.presented && this.columns.map(function (c) {\n        return h(\"ion-picker-column\", {\n          col: c\n        });\n      }), h(\"div\", {\n        class: \"picker-below-highlight\"\n      }))), h(\"div\", {\n        tabindex: \"0\"\n      }));\n    }\n  }, {\n    key: \"el\",\n    get: function get() {\n      return getElement(this);\n    }\n  }]);\n\n  return Picker;\n}();\n\nvar buttonWrapperClass = function buttonWrapperClass(button) {\n  var _ref7;\n\n  return _ref7 = {}, _defineProperty(_ref7, \"picker-toolbar-\".concat(button.role), button.role !== undefined), _defineProperty(_ref7, 'picker-toolbar-button', true), _ref7;\n};\n\nvar buttonClass$1 = function buttonClass$1(button) {\n  return Object.assign({\n    'picker-button': true,\n    'ion-activatable': true\n  }, getClassMap(button.cssClass));\n};\n\nPicker.style = {\n  ios: pickerIosCss,\n  md: pickerMdCss\n};\n/**\n * Returns the dimensions of the popover\n * arrow on `ios` mode. If arrow is disabled\n * returns (0, 0).\n */\n\nvar getArrowDimensions = function getArrowDimensions(arrowEl) {\n  if (!arrowEl) {\n    return {\n      arrowWidth: 0,\n      arrowHeight: 0\n    };\n  }\n\n  var _arrowEl$getBoundingC = arrowEl.getBoundingClientRect(),\n      width = _arrowEl$getBoundingC.width,\n      height = _arrowEl$getBoundingC.height;\n\n  return {\n    arrowWidth: width,\n    arrowHeight: height\n  };\n};\n/**\n * Returns the recommended dimensions of the popover\n * that takes into account whether or not the width\n * should match the trigger width.\n */\n\n\nvar getPopoverDimensions = function getPopoverDimensions(size, contentEl, triggerEl) {\n  var contentDimentions = contentEl.getBoundingClientRect();\n  var contentHeight = contentDimentions.height;\n  var contentWidth = contentDimentions.width;\n\n  if (size === 'cover' && triggerEl) {\n    var triggerDimensions = triggerEl.getBoundingClientRect();\n    contentWidth = triggerDimensions.width;\n  }\n\n  return {\n    contentWidth: contentWidth,\n    contentHeight: contentHeight\n  };\n};\n\nvar configureDismissInteraction = function configureDismissInteraction(triggerEl, triggerAction, popoverEl, parentPopoverEl) {\n  var dismissCallbacks = [];\n  var root = getElementRoot(parentPopoverEl);\n  var parentContentEl = root.querySelector('.popover-content');\n\n  switch (triggerAction) {\n    case 'hover':\n      dismissCallbacks = [{\n        /**\n         * Do not use mouseover here\n         * as this will causes the event to\n         * be dispatched on each underlying\n         * element rather than on the popover\n         * content as a whole.\n         */\n        eventName: 'mouseenter',\n        callback: function callback(ev) {\n          /**\n           * Do not dismiss the popover is we\n           * are hovering over its trigger.\n           * This would be easier if we used mouseover\n           * but this would cause the event to be dispatched\n           * more often than we would like, potentially\n           * causing performance issues.\n           */\n          var element = document.elementFromPoint(ev.clientX, ev.clientY);\n\n          if (element === triggerEl) {\n            return;\n          }\n\n          popoverEl.dismiss(undefined, undefined, false);\n        }\n      }];\n      break;\n\n    case 'context-menu':\n    case 'click':\n    default:\n      dismissCallbacks = [{\n        eventName: 'click',\n        callback: function callback(ev) {\n          /**\n           * Do not dismiss the popover is we\n           * are hovering over its trigger.\n           */\n          var target = ev.target;\n          var closestTrigger = target.closest('[data-ion-popover-trigger]');\n\n          if (closestTrigger === triggerEl) {\n            /**\n             * stopPropagation here so if the\n             * popover has dismissOnSelect=\"true\"\n             * the popover does not dismiss since\n             * we just clicked a trigger element.\n             */\n            ev.stopPropagation();\n            return;\n          }\n\n          popoverEl.dismiss(undefined, undefined, false);\n        }\n      }];\n      break;\n  }\n\n  dismissCallbacks.forEach(function (_ref8) {\n    var eventName = _ref8.eventName,\n        callback = _ref8.callback;\n    return parentContentEl.addEventListener(eventName, callback);\n  });\n  return function () {\n    dismissCallbacks.forEach(function (_ref9) {\n      var eventName = _ref9.eventName,\n          callback = _ref9.callback;\n      return parentContentEl.removeEventListener(eventName, callback);\n    });\n  };\n};\n/**\n * Configures the triggerEl to respond\n * to user interaction based upon the triggerAction\n * prop that devs have defined.\n */\n\n\nvar configureTriggerInteraction = function configureTriggerInteraction(triggerEl, triggerAction, popoverEl) {\n  var triggerCallbacks = [];\n  /**\n   * Based upon the kind of trigger interaction\n   * the user wants, we setup the correct event\n   * listeners.\n   */\n\n  switch (triggerAction) {\n    case 'hover':\n      var hoverTimeout;\n      triggerCallbacks = [{\n        eventName: 'mouseenter',\n        callback: function () {\n          var _callback = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(ev) {\n            return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n              while (1) {\n                switch (_context12.prev = _context12.next) {\n                  case 0:\n                    ev.stopPropagation();\n\n                    if (hoverTimeout) {\n                      clearTimeout(hoverTimeout);\n                    }\n                    /**\n                     * Hovering over a trigger should not\n                     * immediately open the next popover.\n                     */\n\n\n                    hoverTimeout = setTimeout(function () {\n                      raf(function () {\n                        popoverEl.presentFromTrigger(ev);\n                        hoverTimeout = undefined;\n                      });\n                    }, 100);\n\n                  case 3:\n                  case \"end\":\n                    return _context12.stop();\n                }\n              }\n            }, _callee12);\n          }));\n\n          function callback(_x7) {\n            return _callback.apply(this, arguments);\n          }\n\n          return callback;\n        }()\n      }, {\n        eventName: 'mouseleave',\n        callback: function callback(ev) {\n          if (hoverTimeout) {\n            clearTimeout(hoverTimeout);\n          }\n          /**\n           * If mouse is over another popover\n           * that is not this popover then we should\n           * close this popover.\n           */\n\n\n          var target = ev.relatedTarget;\n\n          if (!target) {\n            return;\n          }\n\n          if (target.closest('ion-popover') !== popoverEl) {\n            popoverEl.dismiss(undefined, undefined, false);\n          }\n        }\n      }, {\n        /**\n         * stopPropagation here prevents the popover\n         * from dismissing when dismiss-on-select=\"true\".\n         */\n        eventName: 'click',\n        callback: function callback(ev) {\n          return ev.stopPropagation();\n        }\n      }, {\n        eventName: 'ionPopoverActivateTrigger',\n        callback: function callback(ev) {\n          return popoverEl.presentFromTrigger(ev, true);\n        }\n      }];\n      break;\n\n    case 'context-menu':\n      triggerCallbacks = [{\n        eventName: 'contextmenu',\n        callback: function callback(ev) {\n          /**\n           * Prevents the platform context\n           * menu from appearing.\n           */\n          ev.preventDefault();\n          popoverEl.presentFromTrigger(ev);\n        }\n      }, {\n        eventName: 'click',\n        callback: function callback(ev) {\n          return ev.stopPropagation();\n        }\n      }, {\n        eventName: 'ionPopoverActivateTrigger',\n        callback: function callback(ev) {\n          return popoverEl.presentFromTrigger(ev, true);\n        }\n      }];\n      break;\n\n    case 'click':\n    default:\n      triggerCallbacks = [{\n        /**\n         * Do not do a stopPropagation() here\n         * because if you had two click triggers\n         * then clicking the first trigger and then\n         * clicking the second trigger would not cause\n         * the first popover to dismiss.\n         */\n        eventName: 'click',\n        callback: function callback(ev) {\n          return popoverEl.presentFromTrigger(ev);\n        }\n      }, {\n        eventName: 'ionPopoverActivateTrigger',\n        callback: function callback(ev) {\n          return popoverEl.presentFromTrigger(ev, true);\n        }\n      }];\n      break;\n  }\n\n  triggerCallbacks.forEach(function (_ref10) {\n    var eventName = _ref10.eventName,\n        callback = _ref10.callback;\n    return triggerEl.addEventListener(eventName, callback);\n  });\n  triggerEl.setAttribute('data-ion-popover-trigger', 'true');\n  return function () {\n    triggerCallbacks.forEach(function (_ref11) {\n      var eventName = _ref11.eventName,\n          callback = _ref11.callback;\n      return triggerEl.removeEventListener(eventName, callback);\n    });\n    triggerEl.removeAttribute('data-ion-popover-trigger');\n  };\n};\n/**\n * Returns the index of an ion-item in an array of ion-items.\n */\n\n\nvar getIndexOfItem = function getIndexOfItem(items, item) {\n  if (!item || item.tagName !== 'ION-ITEM') {\n    return -1;\n  }\n\n  return items.findIndex(function (el) {\n    return el === item;\n  });\n};\n/**\n * Given an array of elements and a currently focused ion-item\n * returns the next ion-item relative to the focused one or\n * undefined.\n */\n\n\nvar getNextItem = function getNextItem(items, currentItem) {\n  var currentItemIndex = getIndexOfItem(items, currentItem);\n  return items[currentItemIndex + 1];\n};\n/**\n * Given an array of elements and a currently focused ion-item\n * returns the previous ion-item relative to the focused one or\n * undefined.\n */\n\n\nvar getPrevItem = function getPrevItem(items, currentItem) {\n  var currentItemIndex = getIndexOfItem(items, currentItem);\n  return items[currentItemIndex - 1];\n};\n/** Focus the internal button of the ion-item */\n\n\nvar focusItem = function focusItem(item) {\n  var root = getElementRoot(item);\n  var button = root.querySelector('button');\n\n  if (button) {\n    raf(function () {\n      return button.focus();\n    });\n  }\n};\n/**\n * Returns `true` if `el` has been designated\n * as a trigger element for an ion-popover.\n */\n\n\nvar isTriggerElement = function isTriggerElement(el) {\n  return el.hasAttribute('data-ion-popover-trigger');\n};\n\nvar configureKeyboardInteraction = function configureKeyboardInteraction(popoverEl) {\n  var callback = /*#__PURE__*/function () {\n    var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(ev) {\n      var activeElement, items, parentPopover, nextItem, prevItem, firstItem, lastItem, rightEvent;\n      return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n        while (1) {\n          switch (_context13.prev = _context13.next) {\n            case 0:\n              activeElement = document.activeElement;\n              items = [];\n              /**\n               * Complex selectors with :not() are :not supported\n               * in older versions of Chromium so we need to do a\n               * try/catch here so errors are not thrown.\n               */\n\n              try {\n                /**\n                 * Select all ion-items that are not children of child popovers.\n                 * i.e. only select ion-item elements that are part of this popover\n                 */\n                items = Array.from(popoverEl.querySelectorAll('ion-item:not(ion-popover ion-popover *):not([disabled])'));\n                /* tslint:disable-next-line */\n              } catch (_a) {}\n\n              _context13.t0 = ev.key;\n              _context13.next = _context13.t0 === 'ArrowLeft' ? 6 : _context13.t0 === 'ArrowDown' ? 11 : _context13.t0 === 'ArrowUp' ? 15 : _context13.t0 === 'Home' ? 19 : _context13.t0 === 'End' ? 23 : _context13.t0 === 'ArrowRight' ? 27 : _context13.t0 === ' ' ? 27 : _context13.t0 === 'Enter' ? 27 : 29;\n              break;\n\n            case 6:\n              _context13.next = 8;\n              return popoverEl.getParentPopover();\n\n            case 8:\n              parentPopover = _context13.sent;\n\n              if (parentPopover) {\n                popoverEl.dismiss(undefined, undefined, false);\n              }\n\n              return _context13.abrupt(\"break\", 29);\n\n            case 11:\n              // Disable movement/scroll with keyboard\n              ev.preventDefault();\n              nextItem = getNextItem(items, activeElement); // tslint:disable-next-line:strict-type-predicates\n\n              if (nextItem !== undefined) {\n                focusItem(nextItem);\n              }\n\n              return _context13.abrupt(\"break\", 29);\n\n            case 15:\n              // Disable movement/scroll with keyboard\n              ev.preventDefault();\n              prevItem = getPrevItem(items, activeElement); // tslint:disable-next-line:strict-type-predicates\n\n              if (prevItem !== undefined) {\n                focusItem(prevItem);\n              }\n\n              return _context13.abrupt(\"break\", 29);\n\n            case 19:\n              ev.preventDefault();\n              firstItem = items[0]; // tslint:disable-next-line:strict-type-predicates\n\n              if (firstItem !== undefined) {\n                focusItem(firstItem);\n              }\n\n              return _context13.abrupt(\"break\", 29);\n\n            case 23:\n              ev.preventDefault();\n              lastItem = items[items.length - 1]; // tslint:disable-next-line:strict-type-predicates\n\n              if (lastItem !== undefined) {\n                focusItem(lastItem);\n              }\n\n              return _context13.abrupt(\"break\", 29);\n\n            case 27:\n              if (activeElement && isTriggerElement(activeElement)) {\n                rightEvent = new CustomEvent('ionPopoverActivateTrigger');\n                activeElement.dispatchEvent(rightEvent);\n              }\n\n              return _context13.abrupt(\"break\", 29);\n\n            case 29:\n            case \"end\":\n              return _context13.stop();\n          }\n        }\n      }, _callee13);\n    }));\n\n    return function callback(_x8) {\n      return _ref12.apply(this, arguments);\n    };\n  }();\n\n  popoverEl.addEventListener('keydown', callback);\n  return function () {\n    return popoverEl.removeEventListener('keydown', callback);\n  };\n};\n/**\n * Positions a popover by taking into account\n * the reference point, preferred side, alignment\n * and viewport dimensions.\n */\n\n\nvar getPopoverPosition = function getPopoverPosition(isRTL, contentWidth, contentHeight, arrowWidth, arrowHeight, reference, side, align, defaultPosition, triggerEl, event) {\n  var _a;\n\n  var referenceCoordinates = {\n    top: 0,\n    left: 0,\n    width: 0,\n    height: 0\n  };\n  /**\n   * Calculate position relative to the\n   * x-y coordinates in the event that\n   * was passed in\n   */\n\n  switch (reference) {\n    case 'event':\n      if (!event) {\n        return defaultPosition;\n      }\n\n      var mouseEv = event;\n      referenceCoordinates = {\n        top: mouseEv.clientY,\n        left: mouseEv.clientX,\n        width: 1,\n        height: 1\n      };\n      break;\n\n    /**\n     * Calculate position relative to the bounding\n     * box on either the trigger element\n     * specified via the `trigger` prop or\n     * the target specified on the event\n     * that was passed in.\n     */\n\n    case 'trigger':\n    default:\n      var customEv = event;\n      /**\n       * ionShadowTarget is used when we need to align the\n       * popover with an element inside of the shadow root\n       * of an Ionic component. Ex: Presenting a popover\n       * by clicking on the collapsed indicator inside\n       * of `ion-breadcrumb` and centering it relative\n       * to the indicator rather than `ion-breadcrumb`\n       * as a whole.\n       */\n\n      var actualTriggerEl = triggerEl || ((_a = customEv === null || customEv === void 0 ? void 0 : customEv.detail) === null || _a === void 0 ? void 0 : _a.ionShadowTarget) || (customEv === null || customEv === void 0 ? void 0 : customEv.target);\n\n      if (!actualTriggerEl) {\n        return defaultPosition;\n      }\n\n      var triggerBoundingBox = actualTriggerEl.getBoundingClientRect();\n      referenceCoordinates = {\n        top: triggerBoundingBox.top,\n        left: triggerBoundingBox.left,\n        width: triggerBoundingBox.width,\n        height: triggerBoundingBox.height\n      };\n      break;\n  }\n  /**\n   * Get top/left offset that would allow\n   * popover to be positioned on the\n   * preferred side of the reference.\n   */\n\n\n  var coordinates = calculatePopoverSide(side, referenceCoordinates, contentWidth, contentHeight, arrowWidth, arrowHeight, isRTL);\n  /**\n   * Get the top/left adjustments that\n   * would allow the popover content\n   * to have the correct alignment.\n   */\n\n  var alignedCoordinates = calculatePopoverAlign(align, side, referenceCoordinates, contentWidth, contentHeight);\n  var top = coordinates.top + alignedCoordinates.top;\n  var left = coordinates.left + alignedCoordinates.left;\n\n  var _calculateArrowPositi = calculateArrowPosition(side, arrowWidth, arrowHeight, top, left, contentWidth, contentHeight, isRTL),\n      arrowTop = _calculateArrowPositi.arrowTop,\n      arrowLeft = _calculateArrowPositi.arrowLeft;\n\n  var _calculatePopoverOrig = calculatePopoverOrigin(side, align, isRTL),\n      originX = _calculatePopoverOrig.originX,\n      originY = _calculatePopoverOrig.originY;\n\n  return {\n    top: top,\n    left: left,\n    referenceCoordinates: referenceCoordinates,\n    arrowTop: arrowTop,\n    arrowLeft: arrowLeft,\n    originX: originX,\n    originY: originY\n  };\n};\n/**\n * Determines the transform-origin\n * of the popover animation so that it\n * is in line with what the side and alignment\n * prop values are. Currently only used\n * with the MD animation.\n */\n\n\nvar calculatePopoverOrigin = function calculatePopoverOrigin(side, align, isRTL) {\n  switch (side) {\n    case 'top':\n      return {\n        originX: getOriginXAlignment(align),\n        originY: 'bottom'\n      };\n\n    case 'bottom':\n      return {\n        originX: getOriginXAlignment(align),\n        originY: 'top'\n      };\n\n    case 'left':\n      return {\n        originX: 'right',\n        originY: getOriginYAlignment(align)\n      };\n\n    case 'right':\n      return {\n        originX: 'left',\n        originY: getOriginYAlignment(align)\n      };\n\n    case 'start':\n      return {\n        originX: isRTL ? 'left' : 'right',\n        originY: getOriginYAlignment(align)\n      };\n\n    case 'end':\n      return {\n        originX: isRTL ? 'right' : 'left',\n        originY: getOriginYAlignment(align)\n      };\n  }\n};\n\nvar getOriginXAlignment = function getOriginXAlignment(align) {\n  switch (align) {\n    case 'start':\n      return 'left';\n\n    case 'center':\n      return 'center';\n\n    case 'end':\n      return 'right';\n  }\n};\n\nvar getOriginYAlignment = function getOriginYAlignment(align) {\n  switch (align) {\n    case 'start':\n      return 'top';\n\n    case 'center':\n      return 'center';\n\n    case 'end':\n      return 'bottom';\n  }\n};\n/**\n * Calculates where the arrow positioning\n * should be relative to the popover content.\n */\n\n\nvar calculateArrowPosition = function calculateArrowPosition(side, arrowWidth, arrowHeight, top, left, contentWidth, contentHeight, isRTL) {\n  /**\n   * Note: When side is left, right, start, or end, the arrow is\n   * been rotated using a `transform`, so to move the arrow up or down\n   * by its dimension, you need to use `arrowWidth`.\n   */\n  var leftPosition = {\n    arrowTop: top + contentHeight / 2 - arrowWidth / 2,\n    arrowLeft: left + contentWidth - arrowWidth / 2\n  };\n  /**\n   * Move the arrow to the left by arrowWidth and then\n   * again by half of its width because we have rotated\n   * the arrow using a transform.\n   */\n\n  var rightPosition = {\n    arrowTop: top + contentHeight / 2 - arrowWidth / 2,\n    arrowLeft: left - arrowWidth * 1.5\n  };\n\n  switch (side) {\n    case 'top':\n      return {\n        arrowTop: top + contentHeight,\n        arrowLeft: left + contentWidth / 2 - arrowWidth / 2\n      };\n\n    case 'bottom':\n      return {\n        arrowTop: top - arrowHeight,\n        arrowLeft: left + contentWidth / 2 - arrowWidth / 2\n      };\n\n    case 'left':\n      return leftPosition;\n\n    case 'right':\n      return rightPosition;\n\n    case 'start':\n      return isRTL ? rightPosition : leftPosition;\n\n    case 'end':\n      return isRTL ? leftPosition : rightPosition;\n\n    default:\n      return {\n        arrowTop: 0,\n        arrowLeft: 0\n      };\n  }\n};\n/**\n * Calculates the required top/left\n * values needed to position the popover\n * content on the side specified in the\n * `side` prop.\n */\n\n\nvar calculatePopoverSide = function calculatePopoverSide(side, triggerBoundingBox, contentWidth, contentHeight, arrowWidth, arrowHeight, isRTL) {\n  var sideLeft = {\n    top: triggerBoundingBox.top,\n    left: triggerBoundingBox.left - contentWidth - arrowWidth\n  };\n  var sideRight = {\n    top: triggerBoundingBox.top,\n    left: triggerBoundingBox.left + triggerBoundingBox.width + arrowWidth\n  };\n\n  switch (side) {\n    case 'top':\n      return {\n        top: triggerBoundingBox.top - contentHeight - arrowHeight,\n        left: triggerBoundingBox.left\n      };\n\n    case 'right':\n      return sideRight;\n\n    case 'bottom':\n      return {\n        top: triggerBoundingBox.top + triggerBoundingBox.height + arrowHeight,\n        left: triggerBoundingBox.left\n      };\n\n    case 'left':\n      return sideLeft;\n\n    case 'start':\n      return isRTL ? sideRight : sideLeft;\n\n    case 'end':\n      return isRTL ? sideLeft : sideRight;\n  }\n};\n/**\n * Calculates the required top/left\n * offset values needed to provide the\n * correct alignment regardless while taking\n * into account the side the popover is on.\n */\n\n\nvar calculatePopoverAlign = function calculatePopoverAlign(align, side, triggerBoundingBox, contentWidth, contentHeight) {\n  switch (align) {\n    case 'center':\n      return calculatePopoverCenterAlign(side, triggerBoundingBox, contentWidth, contentHeight);\n\n    case 'end':\n      return calculatePopoverEndAlign(side, triggerBoundingBox, contentWidth, contentHeight);\n\n    case 'start':\n    default:\n      return {\n        top: 0,\n        left: 0\n      };\n  }\n};\n/**\n * Calculate the end alignment for\n * the popover. If side is on the x-axis\n * then the align values refer to the top\n * and bottom margins of the content.\n * If side is on the y-axis then the\n * align values refer to the left and right\n * margins of the content.\n */\n\n\nvar calculatePopoverEndAlign = function calculatePopoverEndAlign(side, triggerBoundingBox, contentWidth, contentHeight) {\n  switch (side) {\n    case 'start':\n    case 'end':\n    case 'left':\n    case 'right':\n      return {\n        top: -(contentHeight - triggerBoundingBox.height),\n        left: 0\n      };\n\n    case 'top':\n    case 'bottom':\n    default:\n      return {\n        top: 0,\n        left: -(contentWidth - triggerBoundingBox.width)\n      };\n  }\n};\n/**\n * Calculate the center alignment for\n * the popover. If side is on the x-axis\n * then the align values refer to the top\n * and bottom margins of the content.\n * If side is on the y-axis then the\n * align values refer to the left and right\n * margins of the content.\n */\n\n\nvar calculatePopoverCenterAlign = function calculatePopoverCenterAlign(side, triggerBoundingBox, contentWidth, contentHeight) {\n  switch (side) {\n    case 'start':\n    case 'end':\n    case 'left':\n    case 'right':\n      return {\n        top: -(contentHeight / 2 - triggerBoundingBox.height / 2),\n        left: 0\n      };\n\n    case 'top':\n    case 'bottom':\n    default:\n      return {\n        top: 0,\n        left: -(contentWidth / 2 - triggerBoundingBox.width / 2)\n      };\n  }\n};\n/**\n * Adjusts popover positioning coordinates\n * such that popover does not appear offscreen\n * or overlapping safe area bounds.\n */\n\n\nvar calculateWindowAdjustment = function calculateWindowAdjustment(side, coordTop, coordLeft, bodyPadding, bodyWidth, bodyHeight, contentWidth, contentHeight, safeAreaMargin, contentOriginX, contentOriginY, triggerCoordinates) {\n  var coordArrowTop = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 0;\n  var coordArrowLeft = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;\n  var arrowHeight = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : 0;\n  var arrowTop = coordArrowTop;\n  var arrowLeft = coordArrowLeft;\n  var left = coordLeft;\n  var top = coordTop;\n  var bottom;\n  var originX = contentOriginX;\n  var originY = contentOriginY;\n  var checkSafeAreaLeft = false;\n  var checkSafeAreaRight = false;\n  var triggerTop = triggerCoordinates ? triggerCoordinates.top + triggerCoordinates.height : bodyHeight / 2 - contentHeight / 2;\n  var triggerHeight = triggerCoordinates ? triggerCoordinates.height : 0;\n  var addPopoverBottomClass = false;\n  /**\n   * Adjust popover so it does not\n   * go off the left of the screen.\n   */\n\n  if (left < bodyPadding + safeAreaMargin) {\n    left = bodyPadding;\n    checkSafeAreaLeft = true;\n    originX = 'left';\n    /**\n     * Adjust popover so it does not\n     * go off the right of the screen.\n     */\n  } else if (contentWidth + bodyPadding + left + safeAreaMargin > bodyWidth) {\n    checkSafeAreaRight = true;\n    left = bodyWidth - contentWidth - bodyPadding;\n    originX = 'right';\n  }\n  /**\n   * Adjust popover so it does not\n   * go off the top of the screen.\n   * If popover is on the left or the right of\n   * the trigger, then we should not adjust top\n   * margins.\n   */\n\n\n  if (triggerTop + triggerHeight + contentHeight > bodyHeight && (side === 'top' || side === 'bottom')) {\n    if (triggerTop - contentHeight > 0) {\n      top = triggerTop - contentHeight - triggerHeight - (arrowHeight - 1);\n      arrowTop = top + contentHeight;\n      originY = 'bottom';\n      addPopoverBottomClass = true;\n      /**\n       * If not enough room for popover to appear\n       * above trigger, then cut it off.\n       */\n    } else {\n      bottom = bodyPadding;\n    }\n  }\n\n  return {\n    top: top,\n    left: left,\n    bottom: bottom,\n    originX: originX,\n    originY: originY,\n    checkSafeAreaLeft: checkSafeAreaLeft,\n    checkSafeAreaRight: checkSafeAreaRight,\n    arrowTop: arrowTop,\n    arrowLeft: arrowLeft,\n    addPopoverBottomClass: addPopoverBottomClass\n  };\n};\n\nvar shouldShowArrow = function shouldShowArrow(side) {\n  var didAdjustBounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var ev = arguments.length > 2 ? arguments[2] : undefined;\n  var trigger = arguments.length > 3 ? arguments[3] : undefined;\n\n  /**\n   * If no event provided and\n   * we do not have a trigger,\n   * then this popover was likely\n   * presented via the popoverController\n   * or users called `present` manually.\n   * In this case, the arrow should not be\n   * shown as we do not have a reference.\n   */\n  if (!ev && !trigger) {\n    return false;\n  }\n  /**\n   * If popover is on the left or the right\n   * of a trigger, but we needed to adjust the\n   * popover due to screen bounds, then we should\n   * hide the arrow as it will never be pointing\n   * at the trigger.\n   */\n\n\n  if (side !== 'top' && side !== 'bottom' && didAdjustBounds) {\n    return false;\n  }\n\n  return true;\n};\n\nvar POPOVER_IOS_BODY_PADDING = 5;\n/**\n * iOS Popover Enter Animation\n */\n\nvar iosEnterAnimation$1 = function iosEnterAnimation$1(baseEl, opts) {\n  var _a;\n\n  var ev = opts.event,\n      size = opts.size,\n      trigger = opts.trigger,\n      reference = opts.reference,\n      side = opts.side,\n      align = opts.align;\n  var doc = baseEl.ownerDocument;\n  var isRTL = doc.dir === 'rtl';\n  var bodyWidth = doc.defaultView.innerWidth;\n  var bodyHeight = doc.defaultView.innerHeight;\n  var root = getElementRoot(baseEl);\n  var contentEl = root.querySelector('.popover-content');\n  var arrowEl = root.querySelector('.popover-arrow');\n  var referenceSizeEl = trigger || ((_a = ev === null || ev === void 0 ? void 0 : ev.detail) === null || _a === void 0 ? void 0 : _a.ionShadowTarget) || (ev === null || ev === void 0 ? void 0 : ev.target);\n\n  var _getPopoverDimensions = getPopoverDimensions(size, contentEl, referenceSizeEl),\n      contentWidth = _getPopoverDimensions.contentWidth,\n      contentHeight = _getPopoverDimensions.contentHeight;\n\n  var _getArrowDimensions = getArrowDimensions(arrowEl),\n      arrowWidth = _getArrowDimensions.arrowWidth,\n      arrowHeight = _getArrowDimensions.arrowHeight;\n\n  var defaultPosition = {\n    top: bodyHeight / 2 - contentHeight / 2,\n    left: bodyWidth / 2 - contentWidth / 2,\n    originX: isRTL ? 'right' : 'left',\n    originY: 'top'\n  };\n  var results = getPopoverPosition(isRTL, contentWidth, contentHeight, arrowWidth, arrowHeight, reference, side, align, defaultPosition, trigger, ev);\n  var padding = size === 'cover' ? 0 : POPOVER_IOS_BODY_PADDING;\n  var margin = size === 'cover' ? 0 : 25;\n\n  var _calculateWindowAdjus = calculateWindowAdjustment(side, results.top, results.left, padding, bodyWidth, bodyHeight, contentWidth, contentHeight, margin, results.originX, results.originY, results.referenceCoordinates, results.arrowTop, results.arrowLeft, arrowHeight),\n      originX = _calculateWindowAdjus.originX,\n      originY = _calculateWindowAdjus.originY,\n      top = _calculateWindowAdjus.top,\n      left = _calculateWindowAdjus.left,\n      bottom = _calculateWindowAdjus.bottom,\n      checkSafeAreaLeft = _calculateWindowAdjus.checkSafeAreaLeft,\n      checkSafeAreaRight = _calculateWindowAdjus.checkSafeAreaRight,\n      arrowTop = _calculateWindowAdjus.arrowTop,\n      arrowLeft = _calculateWindowAdjus.arrowLeft,\n      addPopoverBottomClass = _calculateWindowAdjus.addPopoverBottomClass;\n\n  var baseAnimation = createAnimation();\n  var backdropAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  backdropAnimation.addElement(root.querySelector('ion-backdrop')).fromTo('opacity', 0.01, 'var(--backdrop-opacity)').beforeStyles({\n    'pointer-events': 'none'\n  }).afterClearStyles(['pointer-events']);\n  wrapperAnimation.addElement(root.querySelector('.popover-wrapper')).fromTo('opacity', 0.01, 1);\n  return baseAnimation.easing('ease').duration(100).beforeAddWrite(function () {\n    if (size === 'cover') {\n      baseEl.style.setProperty('--width', \"\".concat(contentWidth, \"px\"));\n    }\n\n    if (addPopoverBottomClass) {\n      baseEl.classList.add('popover-bottom');\n    }\n\n    if (bottom !== undefined) {\n      contentEl.style.setProperty('bottom', \"\".concat(bottom, \"px\"));\n    }\n\n    var safeAreaLeft = ' + var(--ion-safe-area-left, 0)';\n    var safeAreaRight = ' - var(--ion-safe-area-right, 0)';\n    var leftValue = \"\".concat(left, \"px\");\n\n    if (checkSafeAreaLeft) {\n      leftValue = \"\".concat(left, \"px\").concat(safeAreaLeft);\n    }\n\n    if (checkSafeAreaRight) {\n      leftValue = \"\".concat(left, \"px\").concat(safeAreaRight);\n    }\n\n    contentEl.style.setProperty('top', \"calc(\".concat(top, \"px + var(--offset-y, 0))\"));\n    contentEl.style.setProperty('left', \"calc(\".concat(leftValue, \" + var(--offset-x, 0))\"));\n    contentEl.style.setProperty('transform-origin', \"\".concat(originY, \" \").concat(originX));\n\n    if (arrowEl !== null) {\n      var didAdjustBounds = results.top !== top || results.left !== left;\n      var showArrow = shouldShowArrow(side, didAdjustBounds, ev, trigger);\n\n      if (showArrow) {\n        arrowEl.style.setProperty('top', \"calc(\".concat(arrowTop, \"px + var(--offset-y, 0))\"));\n        arrowEl.style.setProperty('left', \"calc(\".concat(arrowLeft, \"px + var(--offset-x, 0))\"));\n      } else {\n        arrowEl.style.setProperty('display', 'none');\n      }\n    }\n  }).addAnimation([backdropAnimation, wrapperAnimation]);\n};\n/**\n * iOS Popover Leave Animation\n */\n\n\nvar iosLeaveAnimation$1 = function iosLeaveAnimation$1(baseEl) {\n  var root = getElementRoot(baseEl);\n  var contentEl = root.querySelector('.popover-content');\n  var arrowEl = root.querySelector('.popover-arrow');\n  var baseAnimation = createAnimation();\n  var backdropAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  backdropAnimation.addElement(root.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0);\n  wrapperAnimation.addElement(root.querySelector('.popover-wrapper')).fromTo('opacity', 0.99, 0);\n  return baseAnimation.easing('ease').afterAddWrite(function () {\n    baseEl.style.removeProperty('--width');\n    baseEl.classList.remove('popover-bottom');\n    contentEl.style.removeProperty('top');\n    contentEl.style.removeProperty('left');\n    contentEl.style.removeProperty('bottom');\n    contentEl.style.removeProperty('transform-origin');\n\n    if (arrowEl) {\n      arrowEl.style.removeProperty('top');\n      arrowEl.style.removeProperty('left');\n      arrowEl.style.removeProperty('display');\n    }\n  }).duration(300).addAnimation([backdropAnimation, wrapperAnimation]);\n};\n\nvar POPOVER_MD_BODY_PADDING = 12;\n/**\n * Md Popover Enter Animation\n */\n\nvar mdEnterAnimation$1 = function mdEnterAnimation$1(baseEl, opts) {\n  var _a;\n\n  var ev = opts.event,\n      size = opts.size,\n      trigger = opts.trigger,\n      reference = opts.reference,\n      side = opts.side,\n      align = opts.align;\n  var doc = baseEl.ownerDocument;\n  var isRTL = doc.dir === 'rtl';\n  var bodyWidth = doc.defaultView.innerWidth;\n  var bodyHeight = doc.defaultView.innerHeight;\n  var root = getElementRoot(baseEl);\n  var contentEl = root.querySelector('.popover-content');\n  var referenceSizeEl = trigger || ((_a = ev === null || ev === void 0 ? void 0 : ev.detail) === null || _a === void 0 ? void 0 : _a.ionShadowTarget) || (ev === null || ev === void 0 ? void 0 : ev.target);\n\n  var _getPopoverDimensions2 = getPopoverDimensions(size, contentEl, referenceSizeEl),\n      contentWidth = _getPopoverDimensions2.contentWidth,\n      contentHeight = _getPopoverDimensions2.contentHeight;\n\n  var defaultPosition = {\n    top: bodyHeight / 2 - contentHeight / 2,\n    left: bodyWidth / 2 - contentWidth / 2,\n    originX: isRTL ? 'right' : 'left',\n    originY: 'top'\n  };\n  var results = getPopoverPosition(isRTL, contentWidth, contentHeight, 0, 0, reference, side, align, defaultPosition, trigger, ev);\n  var padding = size === 'cover' ? 0 : POPOVER_MD_BODY_PADDING;\n\n  var _calculateWindowAdjus2 = calculateWindowAdjustment(side, results.top, results.left, padding, bodyWidth, bodyHeight, contentWidth, contentHeight, 0, results.originX, results.originY, results.referenceCoordinates),\n      originX = _calculateWindowAdjus2.originX,\n      originY = _calculateWindowAdjus2.originY,\n      top = _calculateWindowAdjus2.top,\n      left = _calculateWindowAdjus2.left,\n      bottom = _calculateWindowAdjus2.bottom;\n\n  var baseAnimation = createAnimation();\n  var backdropAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  var contentAnimation = createAnimation();\n  var viewportAnimation = createAnimation();\n  backdropAnimation.addElement(root.querySelector('ion-backdrop')).fromTo('opacity', 0.01, 'var(--backdrop-opacity)').beforeStyles({\n    'pointer-events': 'none'\n  }).afterClearStyles(['pointer-events']);\n  wrapperAnimation.addElement(root.querySelector('.popover-wrapper')).duration(150).fromTo('opacity', 0.01, 1);\n  contentAnimation.addElement(contentEl).beforeStyles({\n    'top': \"calc(\".concat(top, \"px + var(--offset-y, 0px))\"),\n    'left': \"calc(\".concat(left, \"px + var(--offset-x, 0px))\"),\n    'transform-origin': \"\".concat(originY, \" \").concat(originX)\n  }).beforeAddWrite(function () {\n    if (bottom !== undefined) {\n      contentEl.style.setProperty('bottom', \"\".concat(bottom, \"px\"));\n    }\n  }).fromTo('transform', 'scale(0.8)', 'scale(1)');\n  viewportAnimation.addElement(root.querySelector('.popover-viewport')).fromTo('opacity', 0.01, 1);\n  return baseAnimation.easing('cubic-bezier(0.36,0.66,0.04,1)').duration(300).beforeAddWrite(function () {\n    if (size === 'cover') {\n      baseEl.style.setProperty('--width', \"\".concat(contentWidth, \"px\"));\n    }\n\n    if (originY === 'bottom') {\n      baseEl.classList.add('popover-bottom');\n    }\n  }).addAnimation([backdropAnimation, wrapperAnimation, contentAnimation, viewportAnimation]);\n};\n/**\n * Md Popover Leave Animation\n */\n\n\nvar mdLeaveAnimation$1 = function mdLeaveAnimation$1(baseEl) {\n  var root = getElementRoot(baseEl);\n  var contentEl = root.querySelector('.popover-content');\n  var baseAnimation = createAnimation();\n  var backdropAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  backdropAnimation.addElement(root.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0);\n  wrapperAnimation.addElement(root.querySelector('.popover-wrapper')).fromTo('opacity', 0.99, 0);\n  return baseAnimation.easing('ease').afterAddWrite(function () {\n    baseEl.style.removeProperty('--width');\n    baseEl.classList.remove('popover-bottom');\n    contentEl.style.removeProperty('top');\n    contentEl.style.removeProperty('left');\n    contentEl.style.removeProperty('bottom');\n    contentEl.style.removeProperty('transform-origin');\n  }).duration(150).addAnimation([backdropAnimation, wrapperAnimation]);\n};\n\nvar popoverIosCss = \":host{--background:var(--ion-background-color, #fff);--min-width:0;--min-height:0;--max-width:auto;--height:auto;--offset-x:0px;--offset-y:0px;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:fixed;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;color:var(--ion-text-color, #000);z-index:1001;pointer-events:none}:host(.popover-interactive) .popover-content,:host(.popover-interactive) ion-backdrop{pointer-events:auto}:host(.overlay-hidden){display:none}.popover-wrapper{opacity:0;z-index:10}.popover-content{display:-ms-flexbox;display:flex;position:absolute;-ms-flex-direction:column;flex-direction:column;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:auto;z-index:10}.popover-viewport{--ion-safe-area-top:0px;--ion-safe-area-right:0px;--ion-safe-area-bottom:0px;--ion-safe-area-left:0px;display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;overflow:hidden}:host(.popover-nested.popover-side-left){--offset-x:5px}:host(.popover-nested.popover-side-right){--offset-x:-5px}:host(.popover-nested.popover-side-start){--offset-x:5px}:host-context([dir=rtl]):host(.popover-nested.popover-side-start),:host-context([dir=rtl]).popover-nested.popover-side-start{--offset-x:-5px}:host(.popover-nested.popover-side-end){--offset-x:-5px}:host-context([dir=rtl]):host(.popover-nested.popover-side-end),:host-context([dir=rtl]).popover-nested.popover-side-end{--offset-x:5px}:host{--width:200px;--max-height:90%;--box-shadow:none;--backdrop-opacity:var(--ion-backdrop-opacity, 0.08)}:host(.popover-desktop){--box-shadow:0px 4px 16px 0px rgba(0, 0, 0, 0.12)}.popover-content{border-radius:10px}:host(.popover-desktop) .popover-content{border:0.5px solid var(--ion-color-step-100, #e6e6e6)}.popover-arrow{display:block;position:absolute;width:20px;height:10px;overflow:hidden}.popover-arrow::after{left:3px;top:3px;border-radius:3px;position:absolute;width:14px;height:14px;-webkit-transform:rotate(45deg);transform:rotate(45deg);background:var(--background);content:\\\"\\\";z-index:10}[dir=rtl] .popover-arrow::after,:host-context([dir=rtl]) .popover-arrow::after{left:unset;right:unset;right:3px}:host(.popover-bottom) .popover-arrow{top:auto;bottom:-10px}:host(.popover-bottom) .popover-arrow::after{top:-6px}:host(.popover-side-left) .popover-arrow{-webkit-transform:rotate(90deg);transform:rotate(90deg)}:host(.popover-side-right) .popover-arrow{-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}:host(.popover-side-top) .popover-arrow{-webkit-transform:rotate(180deg);transform:rotate(180deg)}:host(.popover-side-start) .popover-arrow{-webkit-transform:rotate(90deg);transform:rotate(90deg)}:host-context([dir=rtl]):host(.popover-side-start) .popover-arrow,:host-context([dir=rtl]).popover-side-start .popover-arrow{-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}:host(.popover-side-end) .popover-arrow{-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}:host-context([dir=rtl]):host(.popover-side-end) .popover-arrow,:host-context([dir=rtl]).popover-side-end .popover-arrow{-webkit-transform:rotate(90deg);transform:rotate(90deg)}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){:host(.popover-translucent) .popover-content,:host(.popover-translucent) .popover-arrow::after{background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8);-webkit-backdrop-filter:saturate(180%) blur(20px);backdrop-filter:saturate(180%) blur(20px)}}\";\nvar popoverMdCss = \":host{--background:var(--ion-background-color, #fff);--min-width:0;--min-height:0;--max-width:auto;--height:auto;--offset-x:0px;--offset-y:0px;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:fixed;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;color:var(--ion-text-color, #000);z-index:1001;pointer-events:none}:host(.popover-interactive) .popover-content,:host(.popover-interactive) ion-backdrop{pointer-events:auto}:host(.overlay-hidden){display:none}.popover-wrapper{opacity:0;z-index:10}.popover-content{display:-ms-flexbox;display:flex;position:absolute;-ms-flex-direction:column;flex-direction:column;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:auto;z-index:10}.popover-viewport{--ion-safe-area-top:0px;--ion-safe-area-right:0px;--ion-safe-area-bottom:0px;--ion-safe-area-left:0px;display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;overflow:hidden}:host(.popover-nested.popover-side-left){--offset-x:5px}:host(.popover-nested.popover-side-right){--offset-x:-5px}:host(.popover-nested.popover-side-start){--offset-x:5px}:host-context([dir=rtl]):host(.popover-nested.popover-side-start),:host-context([dir=rtl]).popover-nested.popover-side-start{--offset-x:-5px}:host(.popover-nested.popover-side-end){--offset-x:-5px}:host-context([dir=rtl]):host(.popover-nested.popover-side-end),:host-context([dir=rtl]).popover-nested.popover-side-end{--offset-x:5px}:host{--width:250px;--max-height:90%;--box-shadow:0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12);--backdrop-opacity:var(--ion-backdrop-opacity, 0.32)}.popover-content{border-radius:4px;-webkit-transform-origin:left top;transform-origin:left top}[dir=rtl] .popover-content,:host-context([dir=rtl]) .popover-content{-webkit-transform-origin:right top;transform-origin:right top}.popover-viewport{-webkit-transition-delay:100ms;transition-delay:100ms}\";\n\nvar Popover = /*#__PURE__*/function () {\n  function Popover(hostRef) {\n    var _this24 = this;\n\n    _classCallCheck(this, Popover);\n\n    registerInstance(this, hostRef);\n    this.didPresent = createEvent(this, \"ionPopoverDidPresent\", 7);\n    this.willPresent = createEvent(this, \"ionPopoverWillPresent\", 7);\n    this.willDismiss = createEvent(this, \"ionPopoverWillDismiss\", 7);\n    this.didDismiss = createEvent(this, \"ionPopoverDidDismiss\", 7);\n    this.didPresentShorthand = createEvent(this, \"didPresent\", 7);\n    this.willPresentShorthand = createEvent(this, \"willPresent\", 7);\n    this.willDismissShorthand = createEvent(this, \"willDismiss\", 7);\n    this.didDismissShorthand = createEvent(this, \"didDismiss\", 7);\n    this.parentPopover = null;\n    this.popoverIndex = popoverIds++;\n    this.coreDelegate = CoreDelegate();\n    this.inline = false;\n    this.focusDescendantOnPresent = false;\n    this.presented = false;\n    /** @internal */\n\n    this.hasController = false;\n    /**\n     * If `true`, the keyboard will be automatically dismissed when the overlay is presented.\n     */\n\n    this.keyboardClose = true;\n    /**\n     * If `true`, the popover will be dismissed when the backdrop is clicked.\n     */\n\n    this.backdropDismiss = true;\n    /**\n     * If `true`, a backdrop will be displayed behind the popover.\n     */\n\n    this.showBackdrop = true;\n    /**\n     * If `true`, the popover will be translucent.\n     * Only applies when the mode is `\"ios\"` and the device supports\n     * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).\n     */\n\n    this.translucent = false;\n    /**\n     * If `true`, the popover will animate.\n     */\n\n    this.animated = true;\n    /**\n     * Describes what kind of interaction with the trigger that\n     * should cause the popover to open. Does not apply when the `trigger`\n     * property is `undefined`.\n     * If `'click'`, the popover will be presented when the trigger is left clicked.\n     * If `'hover'`, the popover will be presented when a pointer hovers over the trigger.\n     * If `'context-menu'`, the popover will be presented when the trigger is right\n     * clicked on desktop and long pressed on mobile. This will also prevent your\n     * device's normal context menu from appearing.\n     */\n\n    this.triggerAction = 'click';\n    /**\n     * Describes how to calculate the popover width.\n     * If `'cover'`, the popover width will match the width of the trigger.\n     * If `'auto'`, the popover width will be determined by the content in\n     * the popover.\n     */\n\n    this.size = 'auto';\n    /**\n     * If `true`, the popover will be automatically\n     * dismissed when the content has been clicked.\n     */\n\n    this.dismissOnSelect = false;\n    /**\n     * Describes what to position the popover relative to.\n     * If `'trigger'`, the popover will be positioned relative\n     * to the trigger button. If passing in an event, this is\n     * determined via event.target.\n     * If `'event'`, the popover will be positioned relative\n     * to the x/y coordinates of the trigger action. If passing\n     * in an event, this is determined via event.clientX and event.clientY.\n     */\n\n    this.reference = 'trigger';\n    /**\n     * Describes which side of the `reference` point to position\n     * the popover on. The `'start'` and `'end'` values are RTL-aware,\n     * and the `'left'` and `'right'` values are not.\n     */\n\n    this.side = 'bottom';\n    /**\n     * Describes how to align the popover content with the `reference` point.\n     */\n\n    this.alignment = 'start';\n    /**\n     * If `true`, the popover will display an arrow\n     * that points at the `reference` when running in `ios` mode\n     * on mobile. Does not apply in `md` mode or on desktop.\n     */\n\n    this.arrow = true;\n    /**\n     * If `true`, the popover will open. If `false`, the popover will close.\n     * Use this if you need finer grained control over presentation, otherwise\n     * just use the popoverController or the `trigger` property.\n     * Note: `isOpen` will not automatically be set back to `false` when\n     * the popover dismisses. You will need to do that in your code.\n     */\n\n    this.isOpen = false;\n    /**\n     * @internal\n     *\n     * If `true` the popover will not register its own keyboard event handlers.\n     * This allows the contents of the popover to handle their own keyboard interactions.\n     *\n     * If `false`, the popover will register its own keyboard event handlers for\n     * navigating `ion-list` items within a popover (up/down/home/end/etc.).\n     * This will also cancel browser keyboard event bindings to prevent scroll\n     * behavior in a popover using a list of items.\n     */\n\n    this.keyboardEvents = false;\n\n    this.onDismiss = function (ev) {\n      ev.stopPropagation();\n      ev.preventDefault();\n\n      _this24.dismiss();\n    };\n\n    this.onBackdropTap = function () {\n      _this24.dismiss(undefined, BACKDROP);\n    };\n\n    this.onLifecycle = function (modalEvent) {\n      var el = _this24.usersElement;\n      var name = LIFECYCLE_MAP[modalEvent.type];\n\n      if (el && name) {\n        var event = new CustomEvent(name, {\n          bubbles: false,\n          cancelable: false,\n          detail: modalEvent.detail\n        });\n        el.dispatchEvent(event);\n      }\n    };\n\n    this.configureTriggerInteraction = function () {\n      var trigger = _this24.trigger,\n          triggerAction = _this24.triggerAction,\n          el = _this24.el,\n          destroyTriggerInteraction = _this24.destroyTriggerInteraction;\n\n      if (destroyTriggerInteraction) {\n        destroyTriggerInteraction();\n      }\n\n      var triggerEl = _this24.triggerEl = trigger !== undefined ? document.getElementById(trigger) : null;\n\n      if (!triggerEl) {\n        return;\n      }\n\n      _this24.destroyTriggerInteraction = configureTriggerInteraction(triggerEl, triggerAction, el);\n    };\n\n    this.configureKeyboardInteraction = function () {\n      var destroyKeyboardInteraction = _this24.destroyKeyboardInteraction,\n          el = _this24.el;\n\n      if (destroyKeyboardInteraction) {\n        destroyKeyboardInteraction();\n      }\n\n      _this24.destroyKeyboardInteraction = configureKeyboardInteraction(el);\n    };\n\n    this.configureDismissInteraction = function () {\n      var destroyDismissInteraction = _this24.destroyDismissInteraction,\n          parentPopover = _this24.parentPopover,\n          triggerAction = _this24.triggerAction,\n          triggerEl = _this24.triggerEl,\n          el = _this24.el;\n\n      if (!parentPopover || !triggerEl) {\n        return;\n      }\n\n      if (destroyDismissInteraction) {\n        destroyDismissInteraction();\n      }\n\n      _this24.destroyDismissInteraction = configureDismissInteraction(triggerEl, triggerAction, el, parentPopover);\n    };\n  }\n\n  _createClass(Popover, [{\n    key: \"onTriggerChange\",\n    value: function onTriggerChange() {\n      this.configureTriggerInteraction();\n    }\n  }, {\n    key: \"onIsOpenChange\",\n    value: function onIsOpenChange(newValue, oldValue) {\n      if (newValue === true && oldValue === false) {\n        this.present();\n      } else if (newValue === false && oldValue === true) {\n        this.dismiss();\n      }\n    }\n  }, {\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      prepareOverlay(this.el);\n    }\n  }, {\n    key: \"componentWillLoad\",\n    value: function componentWillLoad() {\n      /**\n       * If user has custom ID set then we should\n       * not assign the default incrementing ID.\n       */\n      this.popoverId = this.el.hasAttribute('id') ? this.el.getAttribute('id') : \"ion-popover-\".concat(this.popoverIndex);\n      this.parentPopover = this.el.closest(\"ion-popover:not(#\".concat(this.popoverId, \")\"));\n    }\n  }, {\n    key: \"componentDidLoad\",\n    value: function componentDidLoad() {\n      var _this25 = this;\n\n      var parentPopover = this.parentPopover,\n          isOpen = this.isOpen;\n      /**\n       * If popover was rendered with isOpen=\"true\"\n       * then we should open popover immediately.\n       */\n\n      if (isOpen === true) {\n        raf(function () {\n          return _this25.present();\n        });\n      }\n\n      if (parentPopover) {\n        addEventListener(parentPopover, 'ionPopoverWillDismiss', function () {\n          _this25.dismiss(undefined, undefined, false);\n        });\n      }\n\n      this.configureTriggerInteraction();\n    }\n    /**\n     * When opening a popover from a trigger, we should not be\n     * modifying the `event` prop from inside the component.\n     * Additionally, when pressing the \"Right\" arrow key, we need\n     * to shift focus to the first descendant in the newly presented\n     * popover.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"presentFromTrigger\",\n    value: function () {\n      var _presentFromTrigger = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(event) {\n        var focusDescendant,\n            _args14 = arguments;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                focusDescendant = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : false;\n                this.focusDescendantOnPresent = focusDescendant;\n                _context14.next = 4;\n                return this.present(event);\n\n              case 4:\n                this.focusDescendantOnPresent = false;\n\n              case 5:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function presentFromTrigger(_x9) {\n        return _presentFromTrigger.apply(this, arguments);\n      }\n\n      return presentFromTrigger;\n    }()\n    /**\n     * Determines whether or not an overlay\n     * is being used inline or via a controller/JS\n     * and returns the correct delegate.\n     * By default, subsequent calls to getDelegate\n     * will use a cached version of the delegate.\n     * This is useful for calling dismiss after\n     * present so that the correct delegate is given.\n     */\n\n  }, {\n    key: \"getDelegate\",\n    value: function getDelegate() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.workingDelegate && !force) {\n        return {\n          delegate: this.workingDelegate,\n          inline: this.inline\n        };\n      }\n      /**\n       * If using overlay inline\n       * we potentially need to use the coreDelegate\n       * so that this works in vanilla JS apps.\n       * If a developer has presented this component\n       * via a controller, then we can assume\n       * the component is already in the\n       * correct place.\n       */\n\n\n      var parentEl = this.el.parentNode;\n      var inline = this.inline = parentEl !== null && !this.hasController;\n      var delegate = this.workingDelegate = inline ? this.delegate || this.coreDelegate : this.delegate;\n      return {\n        inline: inline,\n        delegate: delegate\n      };\n    }\n    /**\n     * Present the popover overlay after it has been created.\n     * Developers can pass a mouse, touch, or pointer event\n     * to position the popover relative to where that event\n     * was dispatched.\n     */\n\n  }, {\n    key: \"present\",\n    value: function () {\n      var _present5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(event) {\n        var data, _this$getDelegate3, inline, delegate;\n\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                if (!this.presented) {\n                  _context15.next = 2;\n                  break;\n                }\n\n                return _context15.abrupt(\"return\");\n\n              case 2:\n                if (!(this.currentTransition !== undefined)) {\n                  _context15.next = 5;\n                  break;\n                }\n\n                _context15.next = 5;\n                return this.currentTransition;\n\n              case 5:\n                data = Object.assign(Object.assign({}, this.componentProps), {\n                  popover: this.el\n                });\n                _this$getDelegate3 = this.getDelegate(true), inline = _this$getDelegate3.inline, delegate = _this$getDelegate3.delegate;\n                _context15.next = 9;\n                return attachComponent(delegate, this.el, this.component, ['popover-viewport'], data, inline);\n\n              case 9:\n                this.usersElement = _context15.sent;\n                _context15.next = 12;\n                return deepReady(this.usersElement);\n\n              case 12:\n                if (!this.keyboardEvents) {\n                  this.configureKeyboardInteraction();\n                }\n\n                this.configureDismissInteraction();\n                this.currentTransition = _present(this, 'popoverEnter', iosEnterAnimation$1, mdEnterAnimation$1, {\n                  event: event || this.event,\n                  size: this.size,\n                  trigger: this.triggerEl,\n                  reference: this.reference,\n                  side: this.side,\n                  align: this.alignment\n                });\n                _context15.next = 17;\n                return this.currentTransition;\n\n              case 17:\n                this.currentTransition = undefined;\n                /**\n                 * If popover is nested and was\n                 * presented using the \"Right\" arrow key,\n                 * we need to move focus to the first\n                 * descendant inside of the popover.\n                 */\n\n                if (this.focusDescendantOnPresent) {\n                  focusFirstDescendant(this.el, this.el);\n                }\n\n              case 19:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function present(_x10) {\n        return _present5.apply(this, arguments);\n      }\n\n      return present;\n    }()\n    /**\n     * Dismiss the popover overlay after it has been presented.\n     *\n     * @param data Any data to emit in the dismiss events.\n     * @param role The role of the element that is dismissing the popover. For example, 'cancel' or 'backdrop'.\n     * @param dismissParentPopover If `true`, dismissing this popover will also dismiss\n     * a parent popover if this popover is nested. Defaults to `true`.\n     */\n\n  }, {\n    key: \"dismiss\",\n    value: function () {\n      var _dismiss3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(data, role) {\n        var dismissParentPopover,\n            destroyKeyboardInteraction,\n            destroyDismissInteraction,\n            shouldDismiss,\n            _this$getDelegate4,\n            delegate,\n            _args16 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                dismissParentPopover = _args16.length > 2 && _args16[2] !== undefined ? _args16[2] : true;\n\n                if (!(this.currentTransition !== undefined)) {\n                  _context16.next = 4;\n                  break;\n                }\n\n                _context16.next = 4;\n                return this.currentTransition;\n\n              case 4:\n                destroyKeyboardInteraction = this.destroyKeyboardInteraction, destroyDismissInteraction = this.destroyDismissInteraction;\n\n                if (dismissParentPopover && this.parentPopover) {\n                  this.parentPopover.dismiss(data, role, dismissParentPopover);\n                }\n\n                this.currentTransition = _dismiss(this, data, role, 'popoverLeave', iosLeaveAnimation$1, mdLeaveAnimation$1, this.event);\n                _context16.next = 9;\n                return this.currentTransition;\n\n              case 9:\n                shouldDismiss = _context16.sent;\n\n                if (!shouldDismiss) {\n                  _context16.next = 16;\n                  break;\n                }\n\n                if (destroyKeyboardInteraction) {\n                  destroyKeyboardInteraction();\n                  this.destroyKeyboardInteraction = undefined;\n                }\n\n                if (destroyDismissInteraction) {\n                  destroyDismissInteraction();\n                  this.destroyDismissInteraction = undefined;\n                }\n                /**\n                 * If using popover inline\n                 * we potentially need to use the coreDelegate\n                 * so that this works in vanilla JS apps\n                 */\n\n\n                _this$getDelegate4 = this.getDelegate(), delegate = _this$getDelegate4.delegate;\n                _context16.next = 16;\n                return detachComponent(delegate, this.usersElement);\n\n              case 16:\n                this.currentTransition = undefined;\n                return _context16.abrupt(\"return\", shouldDismiss);\n\n              case 18:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function dismiss(_x11, _x12) {\n        return _dismiss3.apply(this, arguments);\n      }\n\n      return dismiss;\n    }()\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"getParentPopover\",\n    value: function () {\n      var _getParentPopover = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17() {\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                return _context17.abrupt(\"return\", this.parentPopover);\n\n              case 1:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function getParentPopover() {\n        return _getParentPopover.apply(this, arguments);\n      }\n\n      return getParentPopover;\n    }()\n    /**\n     * Returns a promise that resolves when the popover did dismiss.\n     */\n\n  }, {\n    key: \"onDidDismiss\",\n    value: function onDidDismiss() {\n      return eventMethod(this.el, 'ionPopoverDidDismiss');\n    }\n    /**\n     * Returns a promise that resolves when the popover will dismiss.\n     */\n\n  }, {\n    key: \"onWillDismiss\",\n    value: function onWillDismiss() {\n      return eventMethod(this.el, 'ionPopoverWillDismiss');\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _Object$assign8,\n          _this26 = this;\n\n      var mode = getIonMode(this);\n      var onLifecycle = this.onLifecycle,\n          popoverId = this.popoverId,\n          parentPopover = this.parentPopover,\n          dismissOnSelect = this.dismissOnSelect,\n          presented = this.presented,\n          side = this.side,\n          arrow = this.arrow,\n          htmlAttributes = this.htmlAttributes;\n      var desktop = isPlatform('desktop');\n      var enableArrow = arrow && !parentPopover && !desktop;\n      return h(Host, Object.assign({\n        \"aria-modal\": \"true\",\n        \"no-router\": true,\n        tabindex: \"-1\"\n      }, htmlAttributes, {\n        style: {\n          zIndex: \"\".concat(20000 + this.overlayIndex)\n        },\n        id: popoverId,\n        class: Object.assign(Object.assign({}, getClassMap(this.cssClass)), (_Object$assign8 = {}, _defineProperty(_Object$assign8, mode, true), _defineProperty(_Object$assign8, 'popover-translucent', this.translucent), _defineProperty(_Object$assign8, 'overlay-hidden', true), _defineProperty(_Object$assign8, 'popover-interactive', presented), _defineProperty(_Object$assign8, 'popover-desktop', desktop), _defineProperty(_Object$assign8, \"popover-side-\".concat(side), true), _defineProperty(_Object$assign8, 'popover-nested', !!parentPopover), _Object$assign8)),\n        onIonPopoverDidPresent: onLifecycle,\n        onIonPopoverWillPresent: onLifecycle,\n        onIonPopoverWillDismiss: onLifecycle,\n        onIonPopoverDidDismiss: onLifecycle,\n        onIonDismiss: this.onDismiss,\n        onIonBackdropTap: this.onBackdropTap\n      }), !parentPopover && h(\"ion-backdrop\", {\n        tappable: this.backdropDismiss,\n        visible: this.showBackdrop,\n        part: \"backdrop\"\n      }), h(\"div\", {\n        class: \"popover-wrapper ion-overlay-wrapper\",\n        onClick: dismissOnSelect ? function () {\n          return _this26.dismiss();\n        } : undefined\n      }, enableArrow && h(\"div\", {\n        class: \"popover-arrow\",\n        part: \"arrow\"\n      }), h(\"div\", {\n        class: \"popover-content\",\n        part: \"content\"\n      }, h(\"slot\", null))));\n    }\n  }, {\n    key: \"el\",\n    get: function get() {\n      return getElement(this);\n    }\n  }], [{\n    key: \"watchers\",\n    get: function get() {\n      return {\n        \"trigger\": [\"onTriggerChange\"],\n        \"triggerAction\": [\"onTriggerChange\"],\n        \"isOpen\": [\"onIsOpenChange\"]\n      };\n    }\n  }]);\n\n  return Popover;\n}();\n\nvar LIFECYCLE_MAP = {\n  'ionPopoverDidPresent': 'ionViewDidEnter',\n  'ionPopoverWillPresent': 'ionViewWillEnter',\n  'ionPopoverWillDismiss': 'ionViewWillLeave',\n  'ionPopoverDidDismiss': 'ionViewDidLeave'\n};\nvar popoverIds = 0;\nPopover.style = {\n  ios: popoverIosCss,\n  md: popoverMdCss\n};\n/**\n * iOS Toast Enter Animation\n */\n\nvar iosEnterAnimation = function iosEnterAnimation(baseEl, position) {\n  var baseAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  var root = getElementRoot(baseEl);\n  var wrapperEl = root.querySelector('.toast-wrapper');\n  var bottom = \"calc(-10px - var(--ion-safe-area-bottom, 0px))\";\n  var top = \"calc(10px + var(--ion-safe-area-top, 0px))\";\n  wrapperAnimation.addElement(wrapperEl);\n\n  switch (position) {\n    case 'top':\n      wrapperAnimation.fromTo('transform', 'translateY(-100%)', \"translateY(\".concat(top, \")\"));\n      break;\n\n    case 'middle':\n      var topPosition = Math.floor(baseEl.clientHeight / 2 - wrapperEl.clientHeight / 2);\n      wrapperEl.style.top = \"\".concat(topPosition, \"px\");\n      wrapperAnimation.fromTo('opacity', 0.01, 1);\n      break;\n\n    default:\n      wrapperAnimation.fromTo('transform', 'translateY(100%)', \"translateY(\".concat(bottom, \")\"));\n      break;\n  }\n\n  return baseAnimation.easing('cubic-bezier(.155,1.105,.295,1.12)').duration(400).addAnimation(wrapperAnimation);\n};\n/**\n * iOS Toast Leave Animation\n */\n\n\nvar iosLeaveAnimation = function iosLeaveAnimation(baseEl, position) {\n  var baseAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  var root = getElementRoot(baseEl);\n  var wrapperEl = root.querySelector('.toast-wrapper');\n  var bottom = \"calc(-10px - var(--ion-safe-area-bottom, 0px))\";\n  var top = \"calc(10px + var(--ion-safe-area-top, 0px))\";\n  wrapperAnimation.addElement(wrapperEl);\n\n  switch (position) {\n    case 'top':\n      wrapperAnimation.fromTo('transform', \"translateY(\".concat(top, \")\"), 'translateY(-100%)');\n      break;\n\n    case 'middle':\n      wrapperAnimation.fromTo('opacity', 0.99, 0);\n      break;\n\n    default:\n      wrapperAnimation.fromTo('transform', \"translateY(\".concat(bottom, \")\"), 'translateY(100%)');\n      break;\n  }\n\n  return baseAnimation.easing('cubic-bezier(.36,.66,.04,1)').duration(300).addAnimation(wrapperAnimation);\n};\n/**\n * MD Toast Enter Animation\n */\n\n\nvar mdEnterAnimation = function mdEnterAnimation(baseEl, position) {\n  var baseAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  var root = getElementRoot(baseEl);\n  var wrapperEl = root.querySelector('.toast-wrapper');\n  var bottom = \"calc(8px + var(--ion-safe-area-bottom, 0px))\";\n  var top = \"calc(8px + var(--ion-safe-area-top, 0px))\";\n  wrapperAnimation.addElement(wrapperEl);\n\n  switch (position) {\n    case 'top':\n      wrapperEl.style.top = top;\n      wrapperAnimation.fromTo('opacity', 0.01, 1);\n      break;\n\n    case 'middle':\n      var topPosition = Math.floor(baseEl.clientHeight / 2 - wrapperEl.clientHeight / 2);\n      wrapperEl.style.top = \"\".concat(topPosition, \"px\");\n      wrapperAnimation.fromTo('opacity', 0.01, 1);\n      break;\n\n    default:\n      wrapperEl.style.bottom = bottom;\n      wrapperAnimation.fromTo('opacity', 0.01, 1);\n      break;\n  }\n\n  return baseAnimation.easing('cubic-bezier(.36,.66,.04,1)').duration(400).addAnimation(wrapperAnimation);\n};\n/**\n * md Toast Leave Animation\n */\n\n\nvar mdLeaveAnimation = function mdLeaveAnimation(baseEl) {\n  var baseAnimation = createAnimation();\n  var wrapperAnimation = createAnimation();\n  var root = getElementRoot(baseEl);\n  var wrapperEl = root.querySelector('.toast-wrapper');\n  wrapperAnimation.addElement(wrapperEl).fromTo('opacity', 0.99, 0);\n  return baseAnimation.easing('cubic-bezier(.36,.66,.04,1)').duration(300).addAnimation(wrapperAnimation);\n};\n\nvar toastIosCss = \":host{--border-width:0;--border-style:none;--border-color:initial;--box-shadow:none;--min-width:auto;--width:auto;--min-height:auto;--height:auto;--max-height:auto;--white-space:normal;left:0;top:0;display:block;position:absolute;width:100%;height:100%;outline:none;color:var(--color);font-family:var(--ion-font-family, inherit);contain:strict;z-index:1001;pointer-events:none}:host-context([dir=rtl]){left:unset;right:unset;right:0}:host(.overlay-hidden){display:none}:host(.ion-color){--button-color:inherit;color:var(--ion-color-contrast)}:host(.ion-color) .toast-button-cancel{color:inherit}:host(.ion-color) .toast-wrapper{background:var(--ion-color-base)}.toast-wrapper{border-radius:var(--border-radius);left:var(--start);right:var(--end);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow)}[dir=rtl] .toast-wrapper,:host-context([dir=rtl]) .toast-wrapper{left:unset;right:unset;left:var(--end);right:var(--start)}.toast-container{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;pointer-events:auto;height:inherit;min-height:inherit;max-height:inherit;contain:content}.toast-content{display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:center;justify-content:center}.toast-icon{margin-left:16px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.toast-icon{margin-left:unset;-webkit-margin-start:16px;margin-inline-start:16px}}.toast-message{-ms-flex:1;flex:1;white-space:var(--white-space)}.toast-button-group{display:-ms-flexbox;display:flex}.toast-button{border:0;outline:none;color:var(--button-color);z-index:0}.toast-icon,.toast-button-icon{font-size:1.4em}.toast-button-inner{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}@media (any-hover: hover){.toast-button:hover{cursor:pointer}}:host{--background:var(--ion-color-step-50, #f2f2f2);--border-radius:14px;--button-color:var(--ion-color-primary, #3880ff);--color:var(--ion-color-step-850, #262626);--max-width:700px;--start:10px;--end:10px;font-size:14px}.toast-wrapper{margin-left:auto;margin-right:auto;margin-top:auto;margin-bottom:auto;display:block;position:absolute;z-index:10}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.toast-wrapper{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){:host(.toast-translucent) .toast-wrapper{background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8);-webkit-backdrop-filter:saturate(180%) blur(20px);backdrop-filter:saturate(180%) blur(20px)}}.toast-wrapper.toast-top{-webkit-transform:translate3d(0,  -100%,  0);transform:translate3d(0,  -100%,  0);top:0}.toast-wrapper.toast-middle{opacity:0.01}.toast-wrapper.toast-bottom{-webkit-transform:translate3d(0,  100%,  0);transform:translate3d(0,  100%,  0);bottom:0}.toast-content{padding-left:15px;padding-right:15px;padding-top:15px;padding-bottom:15px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.toast-content{padding-left:unset;padding-right:unset;-webkit-padding-start:15px;padding-inline-start:15px;-webkit-padding-end:15px;padding-inline-end:15px}}.toast-header{margin-bottom:2px;font-weight:500}.toast-button{padding-left:15px;padding-right:15px;padding-top:10px;padding-bottom:10px;height:44px;-webkit-transition:background-color, opacity 100ms linear;transition:background-color, opacity 100ms linear;border:0;background-color:transparent;font-family:var(--ion-font-family);font-size:17px;font-weight:500;overflow:hidden}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.toast-button{padding-left:unset;padding-right:unset;-webkit-padding-start:15px;padding-inline-start:15px;-webkit-padding-end:15px;padding-inline-end:15px}}.toast-button.ion-activated{opacity:0.4}@media (any-hover: hover){.toast-button:hover{opacity:0.6}}\";\nvar toastMdCss = \":host{--border-width:0;--border-style:none;--border-color:initial;--box-shadow:none;--min-width:auto;--width:auto;--min-height:auto;--height:auto;--max-height:auto;--white-space:normal;left:0;top:0;display:block;position:absolute;width:100%;height:100%;outline:none;color:var(--color);font-family:var(--ion-font-family, inherit);contain:strict;z-index:1001;pointer-events:none}:host-context([dir=rtl]){left:unset;right:unset;right:0}:host(.overlay-hidden){display:none}:host(.ion-color){--button-color:inherit;color:var(--ion-color-contrast)}:host(.ion-color) .toast-button-cancel{color:inherit}:host(.ion-color) .toast-wrapper{background:var(--ion-color-base)}.toast-wrapper{border-radius:var(--border-radius);left:var(--start);right:var(--end);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow)}[dir=rtl] .toast-wrapper,:host-context([dir=rtl]) .toast-wrapper{left:unset;right:unset;left:var(--end);right:var(--start)}.toast-container{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;pointer-events:auto;height:inherit;min-height:inherit;max-height:inherit;contain:content}.toast-content{display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:center;justify-content:center}.toast-icon{margin-left:16px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.toast-icon{margin-left:unset;-webkit-margin-start:16px;margin-inline-start:16px}}.toast-message{-ms-flex:1;flex:1;white-space:var(--white-space)}.toast-button-group{display:-ms-flexbox;display:flex}.toast-button{border:0;outline:none;color:var(--button-color);z-index:0}.toast-icon,.toast-button-icon{font-size:1.4em}.toast-button-inner{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}@media (any-hover: hover){.toast-button:hover{cursor:pointer}}:host{--background:var(--ion-color-step-800, #333333);--border-radius:4px;--box-shadow:0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, 0.12);--button-color:var(--ion-color-primary, #3880ff);--color:var(--ion-color-step-50, #f2f2f2);--max-width:700px;--start:8px;--end:8px;font-size:14px}.toast-wrapper{margin-left:auto;margin-right:auto;margin-top:auto;margin-bottom:auto;display:block;position:absolute;opacity:0.01;z-index:10}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.toast-wrapper{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}.toast-content{padding-left:16px;padding-right:16px;padding-top:14px;padding-bottom:14px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.toast-content{padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px}}.toast-header{margin-bottom:2px;font-weight:500;line-height:20px}.toast-message{line-height:20px}.toast-button-group-start{margin-left:8px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.toast-button-group-start{margin-left:unset;-webkit-margin-start:8px;margin-inline-start:8px}}.toast-button-group-end{margin-right:8px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.toast-button-group-end{margin-right:unset;-webkit-margin-end:8px;margin-inline-end:8px}}.toast-button{padding-left:15px;padding-right:15px;padding-top:10px;padding-bottom:10px;position:relative;background-color:transparent;font-family:var(--ion-font-family);font-size:14px;font-weight:500;letter-spacing:0.84px;text-transform:uppercase;overflow:hidden}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.toast-button{padding-left:unset;padding-right:unset;-webkit-padding-start:15px;padding-inline-start:15px;-webkit-padding-end:15px;padding-inline-end:15px}}.toast-button-cancel{color:var(--ion-color-step-100, #e6e6e6)}.toast-button-icon-only{border-radius:50%;padding-left:9px;padding-right:9px;padding-top:9px;padding-bottom:9px;width:36px;height:36px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.toast-button-icon-only{padding-left:unset;padding-right:unset;-webkit-padding-start:9px;padding-inline-start:9px;-webkit-padding-end:9px;padding-inline-end:9px}}@media (any-hover: hover){.toast-button:hover{background-color:rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.08)}.toast-button-cancel:hover{background-color:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.08)}}\";\n\nvar Toast = /*#__PURE__*/function () {\n  function Toast(hostRef) {\n    var _this27 = this;\n\n    _classCallCheck(this, Toast);\n\n    registerInstance(this, hostRef);\n    this.didPresent = createEvent(this, \"ionToastDidPresent\", 7);\n    this.willPresent = createEvent(this, \"ionToastWillPresent\", 7);\n    this.willDismiss = createEvent(this, \"ionToastWillDismiss\", 7);\n    this.didDismiss = createEvent(this, \"ionToastDidDismiss\", 7);\n    this.presented = false;\n    /**\n     * How many milliseconds to wait before hiding the toast. By default, it will show\n     * until `dismiss()` is called.\n     */\n\n    this.duration = 0;\n    /**\n     * If `true`, the keyboard will be automatically dismissed when the overlay is presented.\n     */\n\n    this.keyboardClose = false;\n    /**\n     * The position of the toast on the screen.\n     */\n\n    this.position = 'bottom';\n    /**\n     * If `true`, the toast will be translucent.\n     * Only applies when the mode is `\"ios\"` and the device supports\n     * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).\n     */\n\n    this.translucent = false;\n    /**\n     * If `true`, the toast will animate.\n     */\n\n    this.animated = true;\n\n    this.dispatchCancelHandler = function (ev) {\n      var role = ev.detail.role;\n\n      if (isCancel(role)) {\n        var cancelButton = _this27.getButtons().find(function (b) {\n          return b.role === 'cancel';\n        });\n\n        _this27.callButtonHandler(cancelButton);\n      }\n    };\n  }\n\n  _createClass(Toast, [{\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      prepareOverlay(this.el, {\n        trapKeyboardFocus: false\n      });\n    }\n    /**\n     * Present the toast overlay after it has been created.\n     */\n\n  }, {\n    key: \"present\",\n    value: function () {\n      var _present6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18() {\n        var _this28 = this;\n\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                _context18.next = 2;\n                return _present(this, 'toastEnter', iosEnterAnimation, mdEnterAnimation, this.position);\n\n              case 2:\n                if (this.duration > 0) {\n                  this.durationTimeout = setTimeout(function () {\n                    return _this28.dismiss(undefined, 'timeout');\n                  }, this.duration);\n                }\n\n              case 3:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function present() {\n        return _present6.apply(this, arguments);\n      }\n\n      return present;\n    }()\n    /**\n     * Dismiss the toast overlay after it has been presented.\n     *\n     * @param data Any data to emit in the dismiss events.\n     * @param role The role of the element that is dismissing the toast.\n     * This can be useful in a button handler for determining which button was\n     * clicked to dismiss the toast.\n     * Some examples include: ``\"cancel\"`, `\"destructive\"`, \"selected\"`, and `\"backdrop\"`.\n     */\n\n  }, {\n    key: \"dismiss\",\n    value: function dismiss(data, role) {\n      if (this.durationTimeout) {\n        clearTimeout(this.durationTimeout);\n      }\n\n      return _dismiss(this, data, role, 'toastLeave', iosLeaveAnimation, mdLeaveAnimation, this.position);\n    }\n    /**\n     * Returns a promise that resolves when the toast did dismiss.\n     */\n\n  }, {\n    key: \"onDidDismiss\",\n    value: function onDidDismiss() {\n      return eventMethod(this.el, 'ionToastDidDismiss');\n    }\n    /**\n     * Returns a promise that resolves when the toast will dismiss.\n     */\n\n  }, {\n    key: \"onWillDismiss\",\n    value: function onWillDismiss() {\n      return eventMethod(this.el, 'ionToastWillDismiss');\n    }\n  }, {\n    key: \"getButtons\",\n    value: function getButtons() {\n      var buttons = this.buttons ? this.buttons.map(function (b) {\n        return typeof b === 'string' ? {\n          text: b\n        } : b;\n      }) : [];\n      return buttons;\n    }\n  }, {\n    key: \"buttonClick\",\n    value: function () {\n      var _buttonClick3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(button) {\n        var role, shouldDismiss;\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                role = button.role;\n\n                if (!isCancel(role)) {\n                  _context19.next = 3;\n                  break;\n                }\n\n                return _context19.abrupt(\"return\", this.dismiss(undefined, role));\n\n              case 3:\n                _context19.next = 5;\n                return this.callButtonHandler(button);\n\n              case 5:\n                shouldDismiss = _context19.sent;\n\n                if (!shouldDismiss) {\n                  _context19.next = 8;\n                  break;\n                }\n\n                return _context19.abrupt(\"return\", this.dismiss(undefined, role));\n\n              case 8:\n                return _context19.abrupt(\"return\", Promise.resolve());\n\n              case 9:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function buttonClick(_x13) {\n        return _buttonClick3.apply(this, arguments);\n      }\n\n      return buttonClick;\n    }()\n  }, {\n    key: \"callButtonHandler\",\n    value: function () {\n      var _callButtonHandler3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20(button) {\n        var rtn;\n        return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                if (!(button && button.handler)) {\n                  _context20.next = 12;\n                  break;\n                }\n\n                _context20.prev = 1;\n                _context20.next = 4;\n                return safeCall(button.handler);\n\n              case 4:\n                rtn = _context20.sent;\n\n                if (!(rtn === false)) {\n                  _context20.next = 7;\n                  break;\n                }\n\n                return _context20.abrupt(\"return\", false);\n\n              case 7:\n                _context20.next = 12;\n                break;\n\n              case 9:\n                _context20.prev = 9;\n                _context20.t0 = _context20[\"catch\"](1);\n                console.error(_context20.t0);\n\n              case 12:\n                return _context20.abrupt(\"return\", true);\n\n              case 13:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, null, [[1, 9]]);\n      }));\n\n      function callButtonHandler(_x14) {\n        return _callButtonHandler3.apply(this, arguments);\n      }\n\n      return callButtonHandler;\n    }()\n  }, {\n    key: \"renderButtons\",\n    value: function renderButtons(buttons, side) {\n      var _this29 = this;\n\n      if (buttons.length === 0) {\n        return;\n      }\n\n      var mode = getIonMode(this);\n\n      var buttonGroupsClasses = _defineProperty({\n        'toast-button-group': true\n      }, \"toast-button-group-\".concat(side), true);\n\n      return h(\"div\", {\n        class: buttonGroupsClasses\n      }, buttons.map(function (b) {\n        return h(\"button\", {\n          type: \"button\",\n          class: buttonClass(b),\n          tabIndex: 0,\n          onClick: function onClick() {\n            return _this29.buttonClick(b);\n          },\n          part: \"button\"\n        }, h(\"div\", {\n          class: \"toast-button-inner\"\n        }, b.icon && h(\"ion-icon\", {\n          icon: b.icon,\n          slot: b.text === undefined ? 'icon-only' : undefined,\n          class: \"toast-button-icon\"\n        }), b.text), mode === 'md' && h(\"ion-ripple-effect\", {\n          type: b.icon !== undefined && b.text === undefined ? 'unbounded' : 'bounded'\n        }));\n      }));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var allButtons = this.getButtons();\n      var startButtons = allButtons.filter(function (b) {\n        return b.side === 'start';\n      });\n      var endButtons = allButtons.filter(function (b) {\n        return b.side !== 'start';\n      });\n      var mode = getIonMode(this);\n\n      var wrapperClass = _defineProperty({\n        'toast-wrapper': true\n      }, \"toast-\".concat(this.position), true);\n\n      var role = allButtons.length > 0 ? 'dialog' : 'status';\n      return h(Host, Object.assign({\n        role: role,\n        tabindex: \"-1\"\n      }, this.htmlAttributes, {\n        style: {\n          zIndex: \"\".concat(60000 + this.overlayIndex)\n        },\n        class: createColorClasses(this.color, Object.assign(Object.assign(_defineProperty({}, mode, true), getClassMap(this.cssClass)), {\n          'overlay-hidden': true,\n          'toast-translucent': this.translucent\n        })),\n        onIonToastWillDismiss: this.dispatchCancelHandler\n      }), h(\"div\", {\n        class: wrapperClass\n      }, h(\"div\", {\n        class: \"toast-container\",\n        part: \"container\"\n      }, this.renderButtons(startButtons, 'start'), this.icon !== undefined && h(\"ion-icon\", {\n        class: \"toast-icon\",\n        part: \"icon\",\n        icon: this.icon,\n        lazy: false,\n        \"aria-hidden\": \"true\"\n      }), h(\"div\", {\n        class: \"toast-content\"\n      }, this.header !== undefined && h(\"div\", {\n        class: \"toast-header\",\n        part: \"header\"\n      }, this.header), this.message !== undefined && h(\"div\", {\n        class: \"toast-message\",\n        part: \"message\",\n        innerHTML: sanitizeDOMString(this.message)\n      })), this.renderButtons(endButtons, 'end'))));\n    }\n  }, {\n    key: \"el\",\n    get: function get() {\n      return getElement(this);\n    }\n  }]);\n\n  return Toast;\n}();\n\nvar buttonClass = function buttonClass(button) {\n  var _Object$assign10;\n\n  return Object.assign((_Object$assign10 = {\n    'toast-button': true,\n    'toast-button-icon-only': button.icon !== undefined && button.text === undefined\n  }, _defineProperty(_Object$assign10, \"toast-button-\".concat(button.role), button.role !== undefined), _defineProperty(_Object$assign10, 'ion-focusable', true), _defineProperty(_Object$assign10, 'ion-activatable', true), _Object$assign10), getClassMap(button.cssClass));\n};\n\nToast.style = {\n  ios: toastIosCss,\n  md: toastMdCss\n};\nvar lastId = 0;\nvar activeAnimations = new WeakMap();\n\nvar createController = function createController(tagName, customElement, childrenCustomElements) {\n  return {\n    create: function create(options) {\n      return createOverlay(tagName, options, customElement, childrenCustomElements);\n    },\n    dismiss: function dismiss(data, role, id) {\n      return dismissOverlay(document, data, role, tagName, id);\n    },\n    getTop: function getTop() {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21() {\n        return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                return _context21.abrupt(\"return\", getOverlay(document, tagName));\n\n              case 1:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21);\n      }))();\n    }\n  };\n};\n\nvar alertController = /*@__PURE__*/createController('ion-alert', Alert, [{\n  tagName: 'ion-backdrop',\n  customElement: Backdrop\n}]);\nvar actionSheetController = /*@__PURE__*/createController('ion-action-sheet', ActionSheet, [{\n  tagName: 'ion-backdrop',\n  customElement: Backdrop\n}, {\n  tagName: 'ion-ripple-effect',\n  customElement: RippleEffect\n}]);\nvar loadingController = /*@__PURE__*/createController('ion-loading', Loading, [{\n  tagName: 'ion-backdrop',\n  customElement: Backdrop\n}, {\n  tagName: 'ion-spinner',\n  customElement: Spinner\n}]);\nvar modalController = /*@__PURE__*/createController('ion-modal', Modal, [{\n  tagName: 'ion-backdrop',\n  customElement: Backdrop\n}]);\nvar pickerController = /*@__PURE__*/createController('ion-picker', Picker, [{\n  tagName: 'ion-picker-column',\n  customElement: PickerColumnCmp\n}, {\n  tagName: 'ion-backdrop',\n  customElement: Backdrop\n}]);\nvar popoverController = /*@__PURE__*/createController('ion-popover', Popover, [{\n  tagName: 'ion-backdrop',\n  customElement: Backdrop\n}]);\nvar toastController = /*@__PURE__*/createController('ion-toast', Toast, [{\n  tagName: 'ion-ripple-effect',\n  customElement: RippleEffect\n}]);\n\nvar prepareOverlay = function prepareOverlay(el) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    trapKeyboardFocus: true\n  };\n\n  /* tslint:disable-next-line */\n  if (typeof document !== 'undefined') {\n    connectListeners(document, options);\n  }\n\n  var overlayIndex = lastId++;\n  el.overlayIndex = overlayIndex;\n\n  if (!el.hasAttribute('id')) {\n    el.id = \"ion-overlay-\".concat(overlayIndex);\n  }\n};\n\nvar registerOverlayComponents = function registerOverlayComponents(tagName, customElement, childrenCustomElements) {\n  var _window = window,\n      customElements = _window.customElements;\n\n  if (!customElements.get(tagName)) {\n    customElements.define(tagName, customElement);\n  }\n  /**\n   * If the parent element has nested usage of custom elements,\n   * we need to manually define those custom elements.\n   */\n\n\n  if (childrenCustomElements) {\n    var _iterator2 = _createForOfIteratorHelper(childrenCustomElements),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var customElementDefinition = _step2.value;\n\n        if (!customElements.get(customElementDefinition.tagName)) {\n          customElements.define(customElementDefinition.tagName, customElementDefinition.customElement);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  return customElements.whenDefined(tagName);\n};\n\nvar createOverlay = function createOverlay(tagName, opts, customElement, childrenCustomElements) {\n  /* tslint:disable-next-line */\n  if (typeof window !== 'undefined' && typeof window.customElements !== 'undefined') {\n    return registerOverlayComponents(tagName, customElement, childrenCustomElements).then(function () {\n      var element = document.createElement(tagName);\n      element.classList.add('overlay-hidden');\n      /**\n       * Convert the passed in overlay options into props\n       * that get passed down into the new overlay.\n       */\n\n      Object.assign(element, Object.assign(Object.assign({}, opts), {\n        hasController: true\n      })); // append the overlay element to the document body\n\n      getAppRoot(document).appendChild(element);\n      return new Promise(function (resolve) {\n        return componentOnReady(element, resolve);\n      });\n    });\n  }\n\n  return Promise.resolve();\n};\n\nvar focusableQueryString = '[tabindex]:not([tabindex^=\"-\"]), input:not([type=hidden]):not([tabindex^=\"-\"]), textarea:not([tabindex^=\"-\"]), button:not([tabindex^=\"-\"]), select:not([tabindex^=\"-\"]), .ion-focusable:not([tabindex^=\"-\"])';\nvar innerFocusableQueryString = 'input:not([type=hidden]), textarea, button, select';\n\nvar focusFirstDescendant = function focusFirstDescendant(ref, overlay) {\n  var firstInput = ref.querySelector(focusableQueryString);\n  var shadowRoot = firstInput && firstInput.shadowRoot;\n\n  if (shadowRoot) {\n    // If there are no inner focusable elements, just focus the host element.\n    firstInput = shadowRoot.querySelector(innerFocusableQueryString) || firstInput;\n  }\n\n  if (firstInput) {\n    focusElement(firstInput);\n  } else {\n    // Focus overlay instead of letting focus escape\n    overlay.focus();\n  }\n};\n\nvar isOverlayHidden = function isOverlayHidden(overlay) {\n  return overlay.classList.contains('overlay-hidden');\n};\n\nvar focusLastDescendant = function focusLastDescendant(ref, overlay) {\n  var inputs = Array.from(ref.querySelectorAll(focusableQueryString));\n  var lastInput = inputs.length > 0 ? inputs[inputs.length - 1] : null;\n  var shadowRoot = lastInput && lastInput.shadowRoot;\n\n  if (shadowRoot) {\n    // If there are no inner focusable elements, just focus the host element.\n    lastInput = shadowRoot.querySelector(innerFocusableQueryString) || lastInput;\n  }\n\n  if (lastInput) {\n    lastInput.focus();\n  } else {\n    // Focus overlay instead of letting focus escape\n    overlay.focus();\n  }\n};\n/**\n * Traps keyboard focus inside of overlay components.\n * Based on https://w3c.github.io/aria-practices/examples/dialog-modal/alertdialog.html\n * This includes the following components: Action Sheet, Alert, Loading, Modal,\n * Picker, and Popover.\n * Should NOT include: Toast\n */\n\n\nvar trapKeyboardFocus = function trapKeyboardFocus(ev, doc) {\n  var lastOverlay = getOverlay(doc);\n  var target = ev.target;\n  /**\n   * If no active overlay, ignore this event.\n   *\n   * If this component uses the shadow dom,\n   * this global listener is pointless\n   * since it will not catch the focus\n   * traps as they are inside the shadow root.\n   * We need to add a listener to the shadow root\n   * itself to ensure the focus trap works.\n   */\n\n  if (!lastOverlay || !target) {\n    return;\n  }\n\n  var trapScopedFocus = function trapScopedFocus() {\n    /**\n     * If we are focusing the overlay, clear\n     * the last focused element so that hitting\n     * tab activates the first focusable element\n     * in the overlay wrapper.\n     */\n    if (lastOverlay === target) {\n      lastOverlay.lastFocus = undefined;\n      /**\n       * Otherwise, we must be focusing an element\n       * inside of the overlay. The two possible options\n       * here are an input/button/etc or the ion-focus-trap\n       * element. The focus trap element is used to prevent\n       * the keyboard focus from leaving the overlay when\n       * using Tab or screen assistants.\n       */\n    } else {\n      /**\n       * We do not want to focus the traps, so get the overlay\n       * wrapper element as the traps live outside of the wrapper.\n       */\n      var overlayRoot = getElementRoot(lastOverlay);\n\n      if (!overlayRoot.contains(target)) {\n        return;\n      }\n\n      var overlayWrapper = overlayRoot.querySelector('.ion-overlay-wrapper');\n\n      if (!overlayWrapper) {\n        return;\n      }\n      /**\n       * If the target is inside the wrapper, let the browser\n       * focus as normal and keep a log of the last focused element.\n       */\n\n\n      if (overlayWrapper.contains(target)) {\n        lastOverlay.lastFocus = target;\n      } else {\n        /**\n         * Otherwise, we must have focused one of the focus traps.\n         * We need to wrap the focus to either the first element\n         * or the last element.\n         */\n\n        /**\n         * Once we call `focusFirstDescendant` and focus the first\n         * descendant, another focus event will fire which will\n         * cause `lastOverlay.lastFocus` to be updated before\n         * we can run the code after that. We will cache the value\n         * here to avoid that.\n         */\n        var lastFocus = lastOverlay.lastFocus; // Focus the first element in the overlay wrapper\n\n        focusFirstDescendant(overlayWrapper, lastOverlay);\n        /**\n         * If the cached last focused element is the\n         * same as the active element, then we need\n         * to wrap focus to the last descendant. This happens\n         * when the first descendant is focused, and the user\n         * presses Shift + Tab. The previous line will focus\n         * the same descendant again (the first one), causing\n         * last focus to equal the active element.\n         */\n\n        if (lastFocus === doc.activeElement) {\n          focusLastDescendant(overlayWrapper, lastOverlay);\n        }\n\n        lastOverlay.lastFocus = doc.activeElement;\n      }\n    }\n  };\n\n  var trapShadowFocus = function trapShadowFocus() {\n    /**\n     * If the target is inside the wrapper, let the browser\n     * focus as normal and keep a log of the last focused element.\n     */\n    if (lastOverlay.contains(target)) {\n      lastOverlay.lastFocus = target;\n    } else {\n      /**\n       * Otherwise, we are about to have focus\n       * go out of the overlay. We need to wrap\n       * the focus to either the first element\n       * or the last element.\n       */\n\n      /**\n       * Once we call `focusFirstDescendant` and focus the first\n       * descendant, another focus event will fire which will\n       * cause `lastOverlay.lastFocus` to be updated before\n       * we can run the code after that. We will cache the value\n       * here to avoid that.\n       */\n      var lastFocus = lastOverlay.lastFocus; // Focus the first element in the overlay wrapper\n\n      focusFirstDescendant(lastOverlay, lastOverlay);\n      /**\n       * If the cached last focused element is the\n       * same as the active element, then we need\n       * to wrap focus to the last descendant. This happens\n       * when the first descendant is focused, and the user\n       * presses Shift + Tab. The previous line will focus\n       * the same descendant again (the first one), causing\n       * last focus to equal the active element.\n       */\n\n      if (lastFocus === doc.activeElement) {\n        focusLastDescendant(lastOverlay, lastOverlay);\n      }\n\n      lastOverlay.lastFocus = doc.activeElement;\n    }\n  };\n\n  if (lastOverlay.shadowRoot) {\n    trapShadowFocus();\n  } else {\n    trapScopedFocus();\n  }\n};\n\nvar connectListeners = function connectListeners(doc, options) {\n  if (lastId === 0) {\n    lastId = 1;\n\n    if (options.trapKeyboardFocus) {\n      doc.addEventListener('focus', function (ev) {\n        /**\n         * ion-menu has its own focus trapping listener\n         * so we do not want the two listeners to conflict\n         * with each other.\n         */\n        if (ev.target && ev.target.tagName === 'ION-MENU') {\n          return;\n        }\n\n        trapKeyboardFocus(ev, doc);\n      }, true);\n    } // handle back-button click\n\n\n    doc.addEventListener('ionBackButton', function (ev) {\n      var lastOverlay = getOverlay(doc);\n\n      if (lastOverlay && lastOverlay.backdropDismiss) {\n        ev.detail.register(OVERLAY_BACK_BUTTON_PRIORITY, function () {\n          return lastOverlay.dismiss(undefined, BACKDROP);\n        });\n      }\n    }); // handle ESC to close overlay\n\n    doc.addEventListener('keyup', function (ev) {\n      if (ev.key === 'Escape') {\n        var lastOverlay = getOverlay(doc);\n\n        if (lastOverlay && lastOverlay.backdropDismiss) {\n          lastOverlay.dismiss(undefined, BACKDROP);\n        }\n      }\n    });\n  }\n};\n\nvar dismissOverlay = function dismissOverlay(doc, data, role, overlayTag, id) {\n  var overlay = getOverlay(doc, overlayTag, id);\n\n  if (!overlay) {\n    return Promise.reject('overlay does not exist');\n  }\n\n  return overlay.dismiss(data, role);\n};\n\nvar getOverlays = function getOverlays(doc, selector) {\n  if (selector === undefined) {\n    selector = 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover,ion-toast';\n  }\n\n  return Array.from(doc.querySelectorAll(selector)).filter(function (c) {\n    return c.overlayIndex > 0;\n  });\n};\n/**\n * Returns an overlay element\n * @param doc The document to find the element within.\n * @param overlayTag The selector for the overlay, defaults to Ionic overlay components.\n * @param id The unique identifier for the overlay instance.\n * @returns The overlay element or `undefined` if no overlay element is found.\n */\n\n\nvar getOverlay = function getOverlay(doc, overlayTag, id) {\n  var overlays = getOverlays(doc, overlayTag).filter(function (o) {\n    return !isOverlayHidden(o);\n  });\n  return id === undefined ? overlays[overlays.length - 1] : overlays.find(function (o) {\n    return o.id === id;\n  });\n};\n/**\n * When an overlay is presented, the main\n * focus is the overlay not the page content.\n * We need to remove the page content from the\n * accessibility tree otherwise when\n * users use \"read screen from top\" gestures with\n * TalkBack and VoiceOver, the screen reader will begin\n * to read the content underneath the overlay.\n *\n * We need a container where all page components\n * exist that is separate from where the overlays\n * are added in the DOM. For most apps, this element\n * is the top most ion-router-outlet. In the event\n * that devs are not using a router,\n * they will need to add the \"ion-view-container-root\"\n * id to the element that contains all of their views.\n *\n * TODO: If Framework supports having multiple top\n * level router outlets we would need to update this.\n * Example: One outlet for side menu and one outlet\n * for main content.\n */\n\n\nvar setRootAriaHidden = function setRootAriaHidden() {\n  var hidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var root = getAppRoot(document);\n  var viewContainer = root.querySelector('ion-router-outlet, ion-nav, #ion-view-container-root');\n\n  if (!viewContainer) {\n    return;\n  }\n\n  if (hidden) {\n    viewContainer.setAttribute('aria-hidden', 'true');\n  } else {\n    viewContainer.removeAttribute('aria-hidden');\n  }\n};\n\nvar _present = /*#__PURE__*/function () {\n  var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22(overlay, name, iosEnterAnimation, mdEnterAnimation, opts) {\n    var _a, _b, mode, animationBuilder, completed;\n\n    return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n      while (1) {\n        switch (_context22.prev = _context22.next) {\n          case 0:\n            if (!overlay.presented) {\n              _context22.next = 2;\n              break;\n            }\n\n            return _context22.abrupt(\"return\");\n\n          case 2:\n            setRootAriaHidden(true);\n            overlay.presented = true;\n            overlay.willPresent.emit();\n            (_a = overlay.willPresentShorthand) === null || _a === void 0 ? void 0 : _a.emit();\n            mode = getIonMode(overlay); // get the user's animation fn if one was provided\n\n            animationBuilder = overlay.enterAnimation ? overlay.enterAnimation : config.get(name, mode === 'ios' ? iosEnterAnimation : mdEnterAnimation);\n            _context22.next = 10;\n            return overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n\n          case 10:\n            completed = _context22.sent;\n\n            if (completed) {\n              overlay.didPresent.emit();\n              (_b = overlay.didPresentShorthand) === null || _b === void 0 ? void 0 : _b.emit();\n            }\n            /**\n             * When an overlay that steals focus\n             * is dismissed, focus should be returned\n             * to the element that was focused\n             * prior to the overlay opening. Toast\n             * does not steal focus and is excluded\n             * from returning focus as a result.\n             */\n\n\n            if (overlay.el.tagName !== 'ION-TOAST') {\n              focusPreviousElementOnDismiss(overlay.el);\n            }\n\n            if (overlay.keyboardClose) {\n              overlay.el.focus();\n            }\n\n          case 14:\n          case \"end\":\n            return _context22.stop();\n        }\n      }\n    }, _callee22);\n  }));\n\n  return function _present(_x15, _x16, _x17, _x18, _x19) {\n    return _ref13.apply(this, arguments);\n  };\n}();\n/**\n * When an overlay component is dismissed,\n * focus should be returned to the element\n * that presented the overlay. Otherwise\n * focus will be set on the body which\n * means that people using screen readers\n * or tabbing will need to re-navigate\n * to where they were before they\n * opened the overlay.\n */\n\n\nvar focusPreviousElementOnDismiss = /*#__PURE__*/function () {\n  var _ref14 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23(overlayEl) {\n    var previousElement, shadowRoot;\n    return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n      while (1) {\n        switch (_context23.prev = _context23.next) {\n          case 0:\n            previousElement = document.activeElement;\n\n            if (previousElement) {\n              _context23.next = 3;\n              break;\n            }\n\n            return _context23.abrupt(\"return\");\n\n          case 3:\n            shadowRoot = previousElement && previousElement.shadowRoot;\n\n            if (shadowRoot) {\n              // If there are no inner focusable elements, just focus the host element.\n              previousElement = shadowRoot.querySelector(innerFocusableQueryString) || previousElement;\n            }\n\n            _context23.next = 7;\n            return overlayEl.onDidDismiss();\n\n          case 7:\n            previousElement.focus();\n\n          case 8:\n          case \"end\":\n            return _context23.stop();\n        }\n      }\n    }, _callee23);\n  }));\n\n  return function focusPreviousElementOnDismiss(_x20) {\n    return _ref14.apply(this, arguments);\n  };\n}();\n\nvar _dismiss = /*#__PURE__*/function () {\n  var _ref15 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee24(overlay, data, role, name, iosLeaveAnimation, mdLeaveAnimation, opts) {\n    var _a, _b, mode, animationBuilder;\n\n    return _regeneratorRuntime.wrap(function _callee24$(_context24) {\n      while (1) {\n        switch (_context24.prev = _context24.next) {\n          case 0:\n            if (overlay.presented) {\n              _context24.next = 2;\n              break;\n            }\n\n            return _context24.abrupt(\"return\", false);\n\n          case 2:\n            setRootAriaHidden(false);\n            overlay.presented = false;\n            _context24.prev = 4;\n            // Overlay contents should not be clickable during dismiss\n            overlay.el.style.setProperty('pointer-events', 'none');\n            overlay.willDismiss.emit({\n              data: data,\n              role: role\n            });\n            (_a = overlay.willDismissShorthand) === null || _a === void 0 ? void 0 : _a.emit({\n              data: data,\n              role: role\n            });\n            mode = getIonMode(overlay);\n            animationBuilder = overlay.leaveAnimation ? overlay.leaveAnimation : config.get(name, mode === 'ios' ? iosLeaveAnimation : mdLeaveAnimation); // If dismissed via gesture, no need to play leaving animation again\n\n            if (!(role !== 'gesture')) {\n              _context24.next = 13;\n              break;\n            }\n\n            _context24.next = 13;\n            return overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n\n          case 13:\n            overlay.didDismiss.emit({\n              data: data,\n              role: role\n            });\n            (_b = overlay.didDismissShorthand) === null || _b === void 0 ? void 0 : _b.emit({\n              data: data,\n              role: role\n            });\n            activeAnimations.delete(overlay); // Make overlay hidden again in case it is being reused\n\n            overlay.el.classList.add('overlay-hidden');\n            _context24.next = 22;\n            break;\n\n          case 19:\n            _context24.prev = 19;\n            _context24.t0 = _context24[\"catch\"](4);\n            console.error(_context24.t0);\n\n          case 22:\n            overlay.el.remove();\n            return _context24.abrupt(\"return\", true);\n\n          case 24:\n          case \"end\":\n            return _context24.stop();\n        }\n      }\n    }, _callee24, null, [[4, 19]]);\n  }));\n\n  return function _dismiss(_x21, _x22, _x23, _x24, _x25, _x26, _x27) {\n    return _ref15.apply(this, arguments);\n  };\n}();\n\nvar getAppRoot = function getAppRoot(doc) {\n  return doc.querySelector('ion-app') || doc.body;\n};\n\nvar overlayAnimation = /*#__PURE__*/function () {\n  var _ref16 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee25(overlay, animationBuilder, baseEl, opts) {\n    var aniRoot, animation, activeAni;\n    return _regeneratorRuntime.wrap(function _callee25$(_context25) {\n      while (1) {\n        switch (_context25.prev = _context25.next) {\n          case 0:\n            // Make overlay visible in case it's hidden\n            baseEl.classList.remove('overlay-hidden');\n            aniRoot = overlay.el;\n            animation = animationBuilder(aniRoot, opts);\n\n            if (!overlay.animated || !config.getBoolean('animated', true)) {\n              animation.duration(0);\n            }\n\n            if (overlay.keyboardClose) {\n              animation.beforeAddWrite(function () {\n                var activeElement = baseEl.ownerDocument.activeElement;\n\n                if (activeElement && activeElement.matches('input,ion-input, ion-textarea')) {\n                  activeElement.blur();\n                }\n              });\n            }\n\n            activeAni = activeAnimations.get(overlay) || [];\n            activeAnimations.set(overlay, [].concat(_toConsumableArray(activeAni), [animation]));\n            _context25.next = 9;\n            return animation.play();\n\n          case 9:\n            return _context25.abrupt(\"return\", true);\n\n          case 10:\n          case \"end\":\n            return _context25.stop();\n        }\n      }\n    }, _callee25);\n  }));\n\n  return function overlayAnimation(_x28, _x29, _x30, _x31) {\n    return _ref16.apply(this, arguments);\n  };\n}();\n\nvar eventMethod = function eventMethod(element, eventName) {\n  var resolve;\n  var promise = new Promise(function (r) {\n    return resolve = r;\n  });\n  onceEvent(element, eventName, function (event) {\n    resolve(event.detail);\n  });\n  return promise;\n};\n\nvar onceEvent = function onceEvent(element, eventName, callback) {\n  var handler = function handler(ev) {\n    removeEventListener(element, eventName, handler);\n    callback(ev);\n  };\n\n  addEventListener(element, eventName, handler);\n};\n\nvar isCancel = function isCancel(role) {\n  return role === 'cancel' || role === BACKDROP;\n};\n\nvar defaultGate = function defaultGate(h) {\n  return h();\n};\n/**\n * Calls a developer provided method while avoiding\n * Angular Zones. Since the handler is provided by\n * the developer, we should throw any errors\n * received so that developer-provided bug\n * tracking software can log it.\n */\n\n\nvar safeCall = function safeCall(handler, arg) {\n  if (typeof handler === 'function') {\n    var jmp = config.get('_zoneGate', defaultGate);\n    return jmp(function () {\n      try {\n        return handler(arg);\n      } catch (e) {\n        throw e;\n      }\n    });\n  }\n\n  return undefined;\n};\n\nvar BACKDROP = 'backdrop';\nexport { ActionSheet as A, Loading as L, Modal as M, Popover as P, Toast as T, alertController as a, actionSheetController as b, popoverController as c, Alert as d, Picker as e, PickerColumnCmp as f, getOverlay as g, loadingController as l, modalController as m, pickerController as p, safeCall as s, toastController as t };","map":null,"metadata":{},"sourceType":"module"}